{"/home/travis/build/npmtest/node-npmtest-coffeelint/test.js":"/* istanbul instrument in package npmtest_coffeelint */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-coffeelint/lib.npmtest_coffeelint.js":"/* istanbul instrument in package npmtest_coffeelint */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_coffeelint = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_coffeelint = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-coffeelint/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-coffeelint && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_coffeelint */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_coffeelint\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_coffeelint.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_coffeelint.rollup.js'] =\n            local.assetsDict['/assets.npmtest_coffeelint.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_coffeelint.__dirname + '/lib.npmtest_coffeelint.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-coffeelint/node_modules/coffeelint/lib/coffeelint.js":"(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.coffeelint = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nmodule.exports={\n  \"name\": \"coffeelint\",\n  \"description\": \"Lint your CoffeeScript\",\n  \"version\": \"1.16.0\",\n  \"homepage\": \"http://www.coffeelint.org\",\n  \"keywords\": [\n    \"lint\",\n    \"coffeescript\",\n    \"coffee-script\"\n  ],\n  \"author\": \"Matthew Perpick <clutchski@gmail.com>\",\n  \"main\": \"./lib/coffeelint.js\",\n  \"engines\": {\n    \"npm\": \">=1.3.7\",\n    \"node\": \">=0.8.0\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/clutchski/coffeelint.git\"\n  },\n  \"bin\": {\n    \"coffeelint\": \"./bin/coffeelint\"\n  },\n  \"dependencies\": {\n    \"coffee-script\": \"~1.11.0\",\n    \"glob\": \"^7.0.6\",\n    \"ignore\": \"^3.0.9\",\n    \"optimist\": \"^0.6.1\",\n    \"resolve\": \"^0.6.3\",\n    \"strip-json-comments\": \"^1.0.2\"\n  },\n  \"devDependencies\": {\n    \"vows\": \">=0.8.1\",\n    \"underscore\": \">=1.4.4\"\n  },\n  \"license\": \"MIT\",\n  \"scripts\": {\n    \"pretest\": \"cake compile\",\n    \"test\": \"./vowsrunner.js --spec test/*.coffee test/*.litcoffee\",\n    \"testrule\": \"npm run compile && ./vowsrunner.js --spec\",\n    \"posttest\": \"npm run lint\",\n    \"prepublish\": \"cake prepublish\",\n    \"postpublish\": \"cake postpublish\",\n    \"publish\": \"cake publish\",\n    \"lint\": \"cake compile && ./bin/coffeelint .\",\n    \"lint-csv\": \"cake compile && ./bin/coffeelint --csv .\",\n    \"lint-jslint\": \"cake compile && ./bin/coffeelint --jslint .\",\n    \"compile\": \"cake compile\"\n  }\n}\n},{}],2:[function(require,module,exports){\nvar ASTApi, ASTLinter, BaseLinter, hasChildren, node_children,\n  hasProp = {}.hasOwnProperty,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };\n\nBaseLinter = require('./base_linter.coffee');\n\nnode_children = {\n  Class: ['variable', 'parent', 'body'],\n  Code: ['params', 'body'],\n  For: ['body', 'source', 'guard', 'step'],\n  If: ['condition', 'body', 'elseBody'],\n  Obj: ['properties'],\n  Op: ['first', 'second'],\n  Switch: ['subject', 'cases', 'otherwise'],\n  Try: ['attempt', 'recovery', 'ensure'],\n  Value: ['base', 'properties'],\n  While: ['condition', 'guard', 'body']\n};\n\nhasChildren = function(node, children) {\n  var ref;\n  return (node != null ? (ref = node.children) != null ? ref.length : void 0 : void 0) === children.length && (node != null ? node.children.every(function(elem, i) {\n    return elem === children[i];\n  }) : void 0);\n};\n\nASTApi = (function() {\n  function ASTApi(config1) {\n    this.config = config1;\n  }\n\n  ASTApi.prototype.getNodeName = function(node) {\n    var children, name, ref;\n    name = node != null ? (ref = node.constructor) != null ? ref.name : void 0 : void 0;\n    if (node_children[name]) {\n      return name;\n    } else {\n      for (name in node_children) {\n        if (!hasProp.call(node_children, name)) continue;\n        children = node_children[name];\n        if (hasChildren(node, children)) {\n          return name;\n        }\n      }\n    }\n  };\n\n  return ASTApi;\n\n})();\n\nmodule.exports = ASTLinter = (function(superClass) {\n  extend(ASTLinter, superClass);\n\n  function ASTLinter(source, config, rules, CoffeeScript) {\n    this.CoffeeScript = CoffeeScript;\n    ASTLinter.__super__.constructor.call(this, source, config, rules);\n    this.astApi = new ASTApi(this.config);\n  }\n\n  ASTLinter.prototype.acceptRule = function(rule) {\n    return typeof rule.lintAST === 'function';\n  };\n\n  ASTLinter.prototype.lint = function() {\n    var coffeeError, err, errors, j, len, ref, rule, v;\n    errors = [];\n    try {\n      this.node = this.CoffeeScript.nodes(this.source);\n    } catch (error) {\n      coffeeError = error;\n      err = this._parseCoffeeScriptError(coffeeError);\n      if (err != null) {\n        errors.push(err);\n      }\n      return errors;\n    }\n    ref = this.rules;\n    for (j = 0, len = ref.length; j < len; j++) {\n      rule = ref[j];\n      this.astApi.createError = (function(_this) {\n        return function(attrs) {\n          if (attrs == null) {\n            attrs = {};\n          }\n          return _this.createError(rule.rule.name, attrs);\n        };\n      })(this);\n      rule.errors = errors;\n      v = this.normalizeResult(rule, rule.lintAST(this.node, this.astApi));\n      if (v != null) {\n        return v;\n      }\n    }\n    return errors;\n  };\n\n  ASTLinter.prototype._parseCoffeeScriptError = function(coffeeError) {\n    var attrs, lineNumber, match, message, rule;\n    rule = this.config['coffeescript_error'];\n    message = coffeeError.toString();\n    lineNumber = -1;\n    if (coffeeError.location != null) {\n      lineNumber = coffeeError.location.first_line + 1;\n    } else {\n      match = /line (\\d+)/.exec(message);\n      if ((match != null ? match.length : void 0) > 1) {\n        lineNumber = parseInt(match[1], 10);\n      }\n    }\n    attrs = {\n      message: message,\n      level: rule.level,\n      lineNumber: lineNumber\n    };\n    return this.createError('coffeescript_error', attrs);\n  };\n\n  return ASTLinter;\n\n})(BaseLinter);\n\n\n},{\"./base_linter.coffee\":3}],3:[function(require,module,exports){\nvar BaseLinter, defaults, extend,\n  slice = [].slice;\n\nextend = function() {\n  var destination, i, k, len, source, sources, v;\n  destination = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n  for (i = 0, len = sources.length; i < len; i++) {\n    source = sources[i];\n    for (k in source) {\n      v = source[k];\n      destination[k] = v;\n    }\n  }\n  return destination;\n};\n\ndefaults = function(source, defaults) {\n  return extend({}, defaults, source);\n};\n\nmodule.exports = BaseLinter = (function() {\n  function BaseLinter(source1, config, rules) {\n    this.source = source1;\n    this.config = config;\n    this.setupRules(rules);\n  }\n\n  BaseLinter.prototype.isObject = function(obj) {\n    return obj === Object(obj);\n  };\n\n  BaseLinter.prototype.createError = function(ruleName, attrs) {\n    var level;\n    if (attrs == null) {\n      attrs = {};\n    }\n    if (attrs.level == null) {\n      attrs.level = this.config[ruleName].level;\n    }\n    level = attrs.level;\n    if (level !== 'ignore' && level !== 'warn' && level !== 'error') {\n      throw new Error(\"unknown level \" + level + \" for rule: \" + ruleName);\n    }\n    if (level === 'error' || level === 'warn') {\n      attrs.rule = ruleName;\n      return defaults(attrs, this.config[ruleName]);\n    } else {\n      return null;\n    }\n  };\n\n  BaseLinter.prototype.acceptRule = function(rule) {\n    throw new Error('acceptRule needs to be overridden in the subclass');\n  };\n\n  BaseLinter.prototype.setupRules = function(rules) {\n    var RuleConstructor, level, name, results, rule;\n    this.rules = [];\n    results = [];\n    for (name in rules) {\n      RuleConstructor = rules[name];\n      level = this.config[name].level;\n      if (level === 'error' || level === 'warn') {\n        rule = new RuleConstructor(this, this.config);\n        if (this.acceptRule(rule)) {\n          results.push(this.rules.push(rule));\n        } else {\n          results.push(void 0);\n        }\n      } else if (level !== 'ignore') {\n        throw new Error(\"unknown level \" + level + \" for rule: \" + rule);\n      } else {\n        results.push(void 0);\n      }\n    }\n    return results;\n  };\n\n  BaseLinter.prototype.normalizeResult = function(p, result) {\n    if (result === true) {\n      return this.createError(p.rule.name);\n    }\n    if (this.isObject(result)) {\n      return this.createError(p.rule.name, result);\n    }\n  };\n\n  return BaseLinter;\n\n})();\n\n\n},{}],4:[function(require,module,exports){\n\n/*\nCoffeeLint\n\nCopyright (c) 2011 Matthew Perpick.\nCoffeeLint is freely distributable under the MIT license.\n */\nvar ASTLinter, CoffeeScript, ERROR, ErrorReport, IGNORE, LexicalLinter, LineLinter, RULES, WARN, _rules, cache, coffeelint, defaults, difference, extend, hasSyntaxError, mergeDefaultConfig, nodeRequire, packageJSON, sameJSON, union,\n  slice = [].slice,\n  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\ncoffeelint = exports;\n\nnodeRequire = require;\n\nif (typeof window !== \"undefined\" && window !== null) {\n  CoffeeScript = window.CoffeeScript;\n}\n\nif (CoffeeScript == null) {\n  CoffeeScript = nodeRequire('coffee-script');\n}\n\nif (CoffeeScript == null) {\n  throw new Error('Unable to find CoffeeScript');\n}\n\npackageJSON = require('./../package.json');\n\ncoffeelint.VERSION = packageJSON.version;\n\nERROR = 'error';\n\nWARN = 'warn';\n\nIGNORE = 'ignore';\n\ncoffeelint.RULES = RULES = require('./rules.coffee');\n\nextend = function() {\n  var destination, j, k, len, source, sources, v;\n  destination = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n  for (j = 0, len = sources.length; j < len; j++) {\n    source = sources[j];\n    for (k in source) {\n      v = source[k];\n      destination[k] = v;\n    }\n  }\n  return destination;\n};\n\ndefaults = function(source, defaults) {\n  return extend({}, defaults, source);\n};\n\nunion = function(a, b) {\n  var c, j, len, len1, n, results, x;\n  c = {};\n  for (j = 0, len = a.length; j < len; j++) {\n    x = a[j];\n    c[x] = true;\n  }\n  for (n = 0, len1 = b.length; n < len1; n++) {\n    x = b[n];\n    c[x] = true;\n  }\n  results = [];\n  for (x in c) {\n    results.push(x);\n  }\n  return results;\n};\n\ndifference = function(a, b) {\n  var j, len, results, x;\n  results = [];\n  for (j = 0, len = a.length; j < len; j++) {\n    x = a[j];\n    if (indexOf.call(b, x) < 0) {\n      results.push(x);\n    }\n  }\n  return results;\n};\n\nLineLinter = require('./line_linter.coffee');\n\nLexicalLinter = require('./lexical_linter.coffee');\n\nASTLinter = require('./ast_linter.coffee');\n\ncache = null;\n\nmergeDefaultConfig = function(userConfig) {\n  var config, rule, ruleConfig, ruleLoader;\n  try {\n    ruleLoader = nodeRequire('./ruleLoader');\n    ruleLoader.loadFromConfig(coffeelint, userConfig);\n  } catch (error) {}\n  config = {};\n  if (userConfig.coffeelint) {\n    config.coffeelint = userConfig.coffeelint;\n  }\n  for (rule in RULES) {\n    ruleConfig = RULES[rule];\n    config[rule] = defaults(userConfig[rule], ruleConfig);\n  }\n  return config;\n};\n\nsameJSON = function(a, b) {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\ncoffeelint.trimConfig = function(userConfig) {\n  var config, dConfig, dValue, key, newConfig, ref, rule, value;\n  newConfig = {};\n  userConfig = mergeDefaultConfig(userConfig);\n  for (rule in userConfig) {\n    config = userConfig[rule];\n    dConfig = RULES[rule];\n    if (rule === 'coffeelint') {\n      config.transforms = config._transforms;\n      delete config._transforms;\n      config.coffeescript = config._coffeescript;\n      delete config._coffeescript;\n      newConfig[rule] = config;\n    } else if ((config.level === (ref = dConfig.level) && ref === 'ignore')) {\n      void 0;\n    } else if (config.level === 'ignore') {\n      newConfig[rule] = {\n        level: 'ignore'\n      };\n    } else {\n      config.module = config._module;\n      delete config._module;\n      for (key in config) {\n        value = config[key];\n        if (key === 'message' || key === 'description' || key === 'name') {\n          continue;\n        }\n        dValue = dConfig[key];\n        if (value !== dValue && !sameJSON(value, dValue)) {\n          if (newConfig[rule] == null) {\n            newConfig[rule] = {};\n          }\n          newConfig[rule][key] = value;\n        }\n      }\n    }\n  }\n  return newConfig;\n};\n\ncoffeelint.invertLiterate = function(source) {\n  var j, len, line, newSource, ref;\n  source = CoffeeScript.helpers.invertLiterate(source);\n  newSource = '';\n  ref = source.split('\\n');\n  for (j = 0, len = ref.length; j < len; j++) {\n    line = ref[j];\n    if (line.match(/^#/)) {\n      line = line.replace(/\\s*$/, '');\n    }\n    line = line.replace(/^[ ]{4}|^\\t/g, '');\n    newSource += line + \"\\n\";\n  }\n  return newSource;\n};\n\n_rules = {};\n\ncoffeelint.registerRule = function(RuleConstructor, ruleName) {\n  var e, name, p, ref, ref1;\n  if (ruleName == null) {\n    ruleName = void 0;\n  }\n  p = new RuleConstructor;\n  name = (p != null ? (ref = p.rule) != null ? ref.name : void 0 : void 0) || '(unknown)';\n  e = function(msg) {\n    throw new Error(\"Invalid rule: \" + name + \" \" + msg);\n  };\n  if (p.rule == null) {\n    e('Rules must provide rule attribute with a default configuration.');\n  }\n  if (p.rule.name == null) {\n    e('Rule defaults require a name');\n  }\n  if ((ruleName != null) && ruleName !== p.rule.name) {\n    e(\"Mismatched rule name: \" + ruleName);\n  }\n  if (p.rule.message == null) {\n    e('Rule defaults require a message');\n  }\n  if (p.rule.description == null) {\n    e('Rule defaults require a description');\n  }\n  if ((ref1 = p.rule.level) !== 'ignore' && ref1 !== 'warn' && ref1 !== 'error') {\n    e(\"Default level must be 'ignore', 'warn', or 'error'\");\n  }\n  if (typeof p.lintToken === 'function') {\n    if (!p.tokens) {\n      e(\"'tokens' is required for 'lintToken'\");\n    }\n  } else if (typeof p.lintLine !== 'function' && typeof p.lintAST !== 'function') {\n    e('Rules must implement lintToken, lintLine, or lintAST');\n  }\n  RULES[p.rule.name] = p.rule;\n  return _rules[p.rule.name] = RuleConstructor;\n};\n\ncoffeelint.getRules = function() {\n  var j, key, len, output, ref;\n  output = {};\n  ref = Object.keys(RULES).sort();\n  for (j = 0, len = ref.length; j < len; j++) {\n    key = ref[j];\n    output[key] = RULES[key];\n  }\n  return output;\n};\n\ncoffeelint.registerRule(require('./rules/arrow_spacing.coffee'));\n\ncoffeelint.registerRule(require('./rules/braces_spacing.coffee'));\n\ncoffeelint.registerRule(require('./rules/no_tabs.coffee'));\n\ncoffeelint.registerRule(require('./rules/no_trailing_whitespace.coffee'));\n\ncoffeelint.registerRule(require('./rules/max_line_length.coffee'));\n\ncoffeelint.registerRule(require('./rules/line_endings.coffee'));\n\ncoffeelint.registerRule(require('./rules/no_trailing_semicolons.coffee'));\n\ncoffeelint.registerRule(require('./rules/indentation.coffee'));\n\ncoffeelint.registerRule(require('./rules/camel_case_classes.coffee'));\n\ncoffeelint.registerRule(require('./rules/colon_assignment_spacing.coffee'));\n\ncoffeelint.registerRule(require('./rules/no_implicit_braces.coffee'));\n\ncoffeelint.registerRule(require('./rules/no_nested_string_interpolation.coffee'));\n\ncoffeelint.registerRule(require('./rules/no_plusplus.coffee'));\n\ncoffeelint.registerRule(require('./rules/no_throwing_strings.coffee'));\n\ncoffeelint.registerRule(require('./rules/no_backticks.coffee'));\n\ncoffeelint.registerRule(require('./rules/no_implicit_parens.coffee'));\n\ncoffeelint.registerRule(require('./rules/no_empty_param_list.coffee'));\n\ncoffeelint.registerRule(require('./rules/no_stand_alone_at.coffee'));\n\ncoffeelint.registerRule(require('./rules/space_operators.coffee'));\n\ncoffeelint.registerRule(require('./rules/duplicate_key.coffee'));\n\ncoffeelint.registerRule(require('./rules/empty_constructor_needs_parens.coffee'));\n\ncoffeelint.registerRule(require('./rules/cyclomatic_complexity.coffee'));\n\ncoffeelint.registerRule(require('./rules/newlines_after_classes.coffee'));\n\ncoffeelint.registerRule(require('./rules/no_unnecessary_fat_arrows.coffee'));\n\ncoffeelint.registerRule(require('./rules/missing_fat_arrows.coffee'));\n\ncoffeelint.registerRule(require('./rules/non_empty_constructor_needs_parens.coffee'));\n\ncoffeelint.registerRule(require('./rules/no_unnecessary_double_quotes.coffee'));\n\ncoffeelint.registerRule(require('./rules/no_debugger.coffee'));\n\ncoffeelint.registerRule(require('./rules/no_interpolation_in_single_quotes.coffee'));\n\ncoffeelint.registerRule(require('./rules/no_empty_functions.coffee'));\n\ncoffeelint.registerRule(require('./rules/prefer_english_operator.coffee'));\n\ncoffeelint.registerRule(require('./rules/spacing_after_comma.coffee'));\n\ncoffeelint.registerRule(require('./rules/transform_messes_up_line_numbers.coffee'));\n\ncoffeelint.registerRule(require('./rules/ensure_comprehensions.coffee'));\n\ncoffeelint.registerRule(require('./rules/no_this.coffee'));\n\ncoffeelint.registerRule(require('./rules/eol_last.coffee'));\n\ncoffeelint.registerRule(require('./rules/no_private_function_fat_arrows.coffee'));\n\nhasSyntaxError = function(source) {\n  try {\n    CoffeeScript.tokens(source);\n    return false;\n  } catch (error) {}\n  return true;\n};\n\nErrorReport = require('./error_report.coffee');\n\ncoffeelint.getErrorReport = function() {\n  return new ErrorReport(coffeelint);\n};\n\ncoffeelint.lint = function(source, userConfig, literate) {\n  var allErrors, astErrors, cmd, config, disabled, disabledEntirely, disabledInitially, disabledLine, e, errors, i, inlineConfig, j, l, len, len1, lexErrors, lexicalLinter, lineErrors, lineLinter, m, n, name, nextLine, o, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, regex, rule, ruleLoader, rules, set, sourceLength, tokensByLine, transform;\n  if (userConfig == null) {\n    userConfig = {};\n  }\n  if (literate == null) {\n    literate = false;\n  }\n  errors = [];\n  if (cache != null) {\n    cache.setConfig(userConfig);\n  }\n  if (cache != null ? cache.has(source) : void 0) {\n    return cache != null ? cache.get(source) : void 0;\n  }\n  config = mergeDefaultConfig(userConfig);\n  if (literate) {\n    source = this.invertLiterate(source);\n  }\n  if ((userConfig != null ? (ref = userConfig.coffeelint) != null ? ref.transforms : void 0 : void 0) != null) {\n    sourceLength = source.split('\\n').length;\n    ref2 = userConfig != null ? (ref1 = userConfig.coffeelint) != null ? ref1.transforms : void 0 : void 0;\n    for (j = 0, len = ref2.length; j < len; j++) {\n      m = ref2[j];\n      try {\n        ruleLoader = nodeRequire('./ruleLoader');\n        transform = ruleLoader.require(m);\n        source = transform(source);\n      } catch (error) {}\n    }\n    if (sourceLength !== source.split('\\n').length && config.transform_messes_up_line_numbers.level !== 'ignore') {\n      errors.push(extend({\n        lineNumber: 1,\n        context: \"File was transformed from \" + sourceLength + \" lines to \" + (source.split(\"\\n\").length) + \" lines\"\n      }, config.transform_messes_up_line_numbers));\n    }\n  }\n  if ((userConfig != null ? (ref3 = userConfig.coffeelint) != null ? ref3.coffeescript : void 0 : void 0) != null) {\n    CoffeeScript = ruleLoader.require(userConfig.coffeelint.coffeescript);\n  }\n  for (name in userConfig) {\n    if (name !== 'coffeescript_error' && name !== '_comment') {\n      if (_rules[name] == null) {\n        void 0;\n      }\n    }\n  }\n  disabledInitially = [];\n  ref4 = source.split('\\n');\n  for (n = 0, len1 = ref4.length; n < len1; n++) {\n    l = ref4[n];\n    ref5 = LineLinter.getDirective(l) || [], regex = ref5[0], set = ref5[1], rule = ref5[ref5.length - 1];\n    if ((set === 'enable' || set === 'enable-line') && ((ref6 = config[rule]) != null ? ref6.level : void 0) === 'ignore') {\n      disabledInitially.push(rule);\n      config[rule].level = 'error';\n    }\n  }\n  astErrors = new ASTLinter(source, config, _rules, CoffeeScript).lint();\n  errors = errors.concat(astErrors);\n  if (!hasSyntaxError(source)) {\n    lexicalLinter = new LexicalLinter(source, config, _rules, CoffeeScript);\n    lexErrors = lexicalLinter.lint();\n    errors = errors.concat(lexErrors);\n    tokensByLine = lexicalLinter.tokensByLine;\n    lineLinter = new LineLinter(source, config, _rules, tokensByLine, literate);\n    lineErrors = lineLinter.lint();\n    errors = errors.concat(lineErrors);\n    inlineConfig = lineLinter.inlineConfig;\n  } else {\n    inlineConfig = {\n      enable: {},\n      disable: {},\n      'enable-line': {},\n      'disable-line': {}\n    };\n  }\n  errors.sort(function(a, b) {\n    return a.lineNumber - b.lineNumber;\n  });\n  disabledEntirely = (function() {\n    var len2, map, o, ref7, result;\n    result = [];\n    map = {};\n    ref7 = errors || [];\n    for (o = 0, len2 = ref7.length; o < len2; o++) {\n      name = ref7[o].name;\n      if (!map[name]) {\n        result.push(name);\n        map[name] = true;\n      }\n    }\n    return result;\n  })();\n  allErrors = errors;\n  errors = [];\n  disabled = disabledInitially;\n  nextLine = 0;\n  for (i = o = 0, ref7 = source.split('\\n').length; 0 <= ref7 ? o < ref7 : o > ref7; i = 0 <= ref7 ? ++o : --o) {\n    disabledLine = disabled;\n    for (cmd in inlineConfig) {\n      rules = inlineConfig[cmd][i];\n      if (rules != null) {\n        ({\n          'disable': function() {\n            if (rules.length) {\n              disabled = union(disabled, rules);\n              return disabledLine = union(disabledLine, rules);\n            } else {\n              return disabled = disabledLine = disabledEntirely;\n            }\n          },\n          'disable-line': function() {\n            if (rules.length) {\n              return disabledLine = union(disabledLine, rules);\n            } else {\n              return disabledLine = disabledEntirely;\n            }\n          },\n          'enable': function() {\n            if (rules.length) {\n              disabled = difference(disabled, rules);\n              return disabledLine = difference(disabledLine, rules);\n            } else {\n              return disabled = disabledLine = disabledInitially;\n            }\n          },\n          'enable-line': function() {\n            if (rules.length) {\n              return disabledLine = difference(disabledLine, rules);\n            } else {\n              return disabledLine = disabledInitially;\n            }\n          }\n        })[cmd]();\n      }\n    }\n    while (nextLine === i && allErrors.length > 0) {\n      nextLine = allErrors[0].lineNumber - 1;\n      e = allErrors[0];\n      if (e.lineNumber === i + 1 || (e.lineNumber == null)) {\n        e = allErrors.shift();\n        if (ref8 = e.rule, indexOf.call(disabledLine, ref8) < 0) {\n          errors.push(e);\n        }\n      }\n    }\n  }\n  if (cache != null) {\n    cache.set(source, errors);\n  }\n  return errors;\n};\n\ncoffeelint.setCache = function(obj) {\n  return cache = obj;\n};\n\n\n},{\"./../package.json\":1,\"./ast_linter.coffee\":2,\"./error_report.coffee\":5,\"./lexical_linter.coffee\":6,\"./line_linter.coffee\":7,\"./rules.coffee\":8,\"./rules/arrow_spacing.coffee\":9,\"./rules/braces_spacing.coffee\":10,\"./rules/camel_case_classes.coffee\":11,\"./rules/colon_assignment_spacing.coffee\":12,\"./rules/cyclomatic_complexity.coffee\":13,\"./rules/duplicate_key.coffee\":14,\"./rules/empty_constructor_needs_parens.coffee\":15,\"./rules/ensure_comprehensions.coffee\":16,\"./rules/eol_last.coffee\":17,\"./rules/indentation.coffee\":18,\"./rules/line_endings.coffee\":19,\"./rules/max_line_length.coffee\":20,\"./rules/missing_fat_arrows.coffee\":21,\"./rules/newlines_after_classes.coffee\":22,\"./rules/no_backticks.coffee\":23,\"./rules/no_debugger.coffee\":24,\"./rules/no_empty_functions.coffee\":25,\"./rules/no_empty_param_list.coffee\":26,\"./rules/no_implicit_braces.coffee\":27,\"./rules/no_implicit_parens.coffee\":28,\"./rules/no_interpolation_in_single_quotes.coffee\":29,\"./rules/no_nested_string_interpolation.coffee\":30,\"./rules/no_plusplus.coffee\":31,\"./rules/no_private_function_fat_arrows.coffee\":32,\"./rules/no_stand_alone_at.coffee\":33,\"./rules/no_tabs.coffee\":34,\"./rules/no_this.coffee\":35,\"./rules/no_throwing_strings.coffee\":36,\"./rules/no_trailing_semicolons.coffee\":37,\"./rules/no_trailing_whitespace.coffee\":38,\"./rules/no_unnecessary_double_quotes.coffee\":39,\"./rules/no_unnecessary_fat_arrows.coffee\":40,\"./rules/non_empty_constructor_needs_parens.coffee\":41,\"./rules/prefer_english_operator.coffee\":42,\"./rules/space_operators.coffee\":43,\"./rules/spacing_after_comma.coffee\":44,\"./rules/transform_messes_up_line_numbers.coffee\":45}],5:[function(require,module,exports){\nvar ErrorReport;\n\nmodule.exports = ErrorReport = (function() {\n  function ErrorReport(coffeelint) {\n    this.coffeelint = coffeelint;\n    this.paths = {};\n  }\n\n  ErrorReport.prototype.lint = function(filename, source, config, literate) {\n    if (config == null) {\n      config = {};\n    }\n    if (literate == null) {\n      literate = false;\n    }\n    return this.paths[filename] = this.coffeelint.lint(source, config, literate);\n  };\n\n  ErrorReport.prototype.getExitCode = function() {\n    var path;\n    for (path in this.paths) {\n      if (this.pathHasError(path)) {\n        return 1;\n      }\n    }\n    return 0;\n  };\n\n  ErrorReport.prototype.getSummary = function() {\n    var error, errorCount, errors, i, len, path, pathCount, ref, warningCount;\n    pathCount = errorCount = warningCount = 0;\n    ref = this.paths;\n    for (path in ref) {\n      errors = ref[path];\n      pathCount++;\n      for (i = 0, len = errors.length; i < len; i++) {\n        error = errors[i];\n        if (error.level === 'error') {\n          errorCount++;\n        }\n        if (error.level === 'warn') {\n          warningCount++;\n        }\n      }\n    }\n    return {\n      errorCount: errorCount,\n      warningCount: warningCount,\n      pathCount: pathCount\n    };\n  };\n\n  ErrorReport.prototype.getErrors = function(path) {\n    return this.paths[path];\n  };\n\n  ErrorReport.prototype.pathHasWarning = function(path) {\n    return this._hasLevel(path, 'warn');\n  };\n\n  ErrorReport.prototype.pathHasError = function(path) {\n    return this._hasLevel(path, 'error');\n  };\n\n  ErrorReport.prototype.hasError = function() {\n    var path;\n    for (path in this.paths) {\n      if (this.pathHasError(path)) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  ErrorReport.prototype._hasLevel = function(path, level) {\n    var error, i, len, ref;\n    ref = this.paths[path];\n    for (i = 0, len = ref.length; i < len; i++) {\n      error = ref[i];\n      if (error.level === level) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  return ErrorReport;\n\n})();\n\n\n},{}],6:[function(require,module,exports){\nvar BaseLinter, LexicalLinter, TokenApi,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty,\n  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\nTokenApi = (function() {\n  function TokenApi(CoffeeScript, source, config1, tokensByLine) {\n    this.config = config1;\n    this.tokensByLine = tokensByLine;\n    this.tokens = CoffeeScript.tokens(source);\n    this.lines = source.split('\\n');\n    this.tokensByLine = {};\n  }\n\n  TokenApi.prototype.i = 0;\n\n  TokenApi.prototype.peek = function(n) {\n    if (n == null) {\n      n = 1;\n    }\n    return this.tokens[this.i + n] || null;\n  };\n\n  return TokenApi;\n\n})();\n\nBaseLinter = require('./base_linter.coffee');\n\nmodule.exports = LexicalLinter = (function(superClass) {\n  extend(LexicalLinter, superClass);\n\n  function LexicalLinter(source, config, rules, CoffeeScript) {\n    LexicalLinter.__super__.constructor.call(this, source, config, rules);\n    this.tokenApi = new TokenApi(CoffeeScript, source, this.config, this.tokensByLine);\n    this.tokensByLine = this.tokenApi.tokensByLine;\n  }\n\n  LexicalLinter.prototype.acceptRule = function(rule) {\n    return typeof rule.lintToken === 'function';\n  };\n\n  LexicalLinter.prototype.lint = function() {\n    var error, errors, i, j, k, len, len1, ref, ref1, token;\n    errors = [];\n    ref = this.tokenApi.tokens;\n    for (i = j = 0, len = ref.length; j < len; i = ++j) {\n      token = ref[i];\n      this.tokenApi.i = i;\n      ref1 = this.lintToken(token);\n      for (k = 0, len1 = ref1.length; k < len1; k++) {\n        error = ref1[k];\n        errors.push(error);\n      }\n    }\n    return errors;\n  };\n\n  LexicalLinter.prototype.lintToken = function(token) {\n    var base, errors, j, len, lineNumber, ref, ref1, ref2, rule, type, v, value;\n    type = token[0], value = token[1], (ref = token[2], lineNumber = ref.first_line);\n    if ((base = this.tokensByLine)[lineNumber] == null) {\n      base[lineNumber] = [];\n    }\n    this.tokensByLine[lineNumber].push(token);\n    this.lineNumber = lineNumber || this.lineNumber || 0;\n    this.tokenApi.lineNumber = this.lineNumber;\n    errors = [];\n    ref1 = this.rules;\n    for (j = 0, len = ref1.length; j < len; j++) {\n      rule = ref1[j];\n      if (!(ref2 = token[0], indexOf.call(rule.tokens, ref2) >= 0)) {\n        continue;\n      }\n      v = this.normalizeResult(rule, rule.lintToken(token, this.tokenApi));\n      if (v != null) {\n        errors.push(v);\n      }\n    }\n    return errors;\n  };\n\n  LexicalLinter.prototype.createError = function(ruleName, attrs) {\n    if (attrs == null) {\n      attrs = {};\n    }\n    if (attrs.lineNumber == null) {\n      attrs.lineNumber = this.lineNumber;\n    }\n    attrs.lineNumber += 1;\n    attrs.line = this.tokenApi.lines[attrs.lineNumber - 1];\n    return LexicalLinter.__super__.createError.call(this, ruleName, attrs);\n  };\n\n  return LexicalLinter;\n\n})(BaseLinter);\n\n\n},{\"./base_linter.coffee\":3}],7:[function(require,module,exports){\nvar BaseLinter, LineApi, LineLinter, configShortcuts, configStatement,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\nLineApi = (function() {\n  function LineApi(source, config1, tokensByLine1, literate1) {\n    this.config = config1;\n    this.tokensByLine = tokensByLine1;\n    this.literate = literate1;\n    this.line = null;\n    this.lines = source.split('\\n');\n    this.lineCount = this.lines.length;\n    this.context = {\n      \"class\": {\n        inClass: false,\n        lastUnemptyLineInClass: null,\n        classIndents: null\n      }\n    };\n  }\n\n  LineApi.prototype.lineNumber = 0;\n\n  LineApi.prototype.isLiterate = function() {\n    return this.literate;\n  };\n\n  LineApi.prototype.maintainClassContext = function(line) {\n    if (this.context[\"class\"].inClass) {\n      if (this.lineHasToken('INDENT')) {\n        this.context[\"class\"].classIndents++;\n      } else if (this.lineHasToken('OUTDENT')) {\n        this.context[\"class\"].classIndents--;\n        if (this.context[\"class\"].classIndents === 0) {\n          this.context[\"class\"].inClass = false;\n          this.context[\"class\"].classIndents = null;\n        }\n      }\n      if (!line.match(/^\\s*$/)) {\n        this.context[\"class\"].lastUnemptyLineInClass = this.lineNumber;\n      }\n    } else {\n      if (!line.match(/\\\\s*/)) {\n        this.context[\"class\"].lastUnemptyLineInClass = null;\n      }\n      if (this.lineHasToken('CLASS')) {\n        this.context[\"class\"].inClass = true;\n        this.context[\"class\"].lastUnemptyLineInClass = this.lineNumber;\n        this.context[\"class\"].classIndents = 0;\n      }\n    }\n    return null;\n  };\n\n  LineApi.prototype.isLastLine = function() {\n    return this.lineNumber === this.lineCount - 1;\n  };\n\n  LineApi.prototype.lineHasToken = function(tokenType, lineNumber) {\n    var i, len, token, tokens;\n    if (tokenType == null) {\n      tokenType = null;\n    }\n    if (lineNumber == null) {\n      lineNumber = null;\n    }\n    lineNumber = lineNumber != null ? lineNumber : this.lineNumber;\n    if (tokenType == null) {\n      return this.tokensByLine[lineNumber] != null;\n    } else {\n      tokens = this.tokensByLine[lineNumber];\n      if (tokens == null) {\n        return null;\n      }\n      for (i = 0, len = tokens.length; i < len; i++) {\n        token = tokens[i];\n        if (token[0] === tokenType) {\n          return true;\n        }\n      }\n      return false;\n    }\n  };\n\n  LineApi.prototype.getLineTokens = function() {\n    return this.tokensByLine[this.lineNumber] || [];\n  };\n\n  return LineApi;\n\n})();\n\nBaseLinter = require('./base_linter.coffee');\n\nconfigStatement = /coffeelint:\\s*((disable|enable)(-line)?)(?:=([\\w\\s,]*))?/;\n\nconfigShortcuts = [[/\\#.*noqa/, 'coffeelint: disable-line']];\n\nmodule.exports = LineLinter = (function(superClass) {\n  extend(LineLinter, superClass);\n\n  LineLinter.getDirective = function(line) {\n    var i, len, ref, replacement, shortcut;\n    for (i = 0, len = configShortcuts.length; i < len; i++) {\n      ref = configShortcuts[i], shortcut = ref[0], replacement = ref[1];\n      if (line.match(shortcut)) {\n        return configStatement.exec(replacement);\n      }\n    }\n    return configStatement.exec(line);\n  };\n\n  function LineLinter(source, config, rules, tokensByLine, literate) {\n    if (literate == null) {\n      literate = false;\n    }\n    LineLinter.__super__.constructor.call(this, source, config, rules);\n    this.lineApi = new LineApi(source, config, tokensByLine, literate);\n    this.inlineConfig = {\n      enable: {},\n      disable: {},\n      'enable-line': {},\n      'disable-line': {}\n    };\n  }\n\n  LineLinter.prototype.acceptRule = function(rule) {\n    return typeof rule.lintLine === 'function';\n  };\n\n  LineLinter.prototype.lint = function() {\n    var error, errors, i, j, len, len1, line, lineNumber, ref, ref1;\n    errors = [];\n    ref = this.lineApi.lines;\n    for (lineNumber = i = 0, len = ref.length; i < len; lineNumber = ++i) {\n      line = ref[lineNumber];\n      this.lineApi.lineNumber = this.lineNumber = lineNumber;\n      this.lineApi.line = this.lineApi.lines[lineNumber];\n      this.lineApi.maintainClassContext(line);\n      this.collectInlineConfig(line);\n      ref1 = this.lintLine(line);\n      for (j = 0, len1 = ref1.length; j < len1; j++) {\n        error = ref1[j];\n        errors.push(error);\n      }\n    }\n    return errors;\n  };\n\n  LineLinter.prototype.lintLine = function(line) {\n    var errors, i, len, ref, rule, v;\n    errors = [];\n    ref = this.rules;\n    for (i = 0, len = ref.length; i < len; i++) {\n      rule = ref[i];\n      v = this.normalizeResult(rule, rule.lintLine(line, this.lineApi));\n      if (v != null) {\n        errors.push(v);\n      }\n    }\n    return errors;\n  };\n\n  LineLinter.prototype.collectInlineConfig = function(line) {\n    var cmd, i, len, r, ref, result, rules;\n    result = this.constructor.getDirective(line);\n    if (result != null) {\n      cmd = result[1];\n      rules = [];\n      if (result[4] != null) {\n        ref = result[4].split(',');\n        for (i = 0, len = ref.length; i < len; i++) {\n          r = ref[i];\n          rules.push(r.replace(/^\\s+|\\s+$/g, ''));\n        }\n      }\n      this.inlineConfig[cmd][this.lineNumber] = rules;\n    }\n    return null;\n  };\n\n  LineLinter.prototype.createError = function(rule, attrs) {\n    var ref;\n    if (attrs == null) {\n      attrs = {};\n    }\n    attrs.lineNumber = this.lineNumber + 1;\n    attrs.level = (ref = this.config[rule]) != null ? ref.level : void 0;\n    return LineLinter.__super__.createError.call(this, rule, attrs);\n  };\n\n  return LineLinter;\n\n})(BaseLinter);\n\n\n},{\"./base_linter.coffee\":3}],8:[function(require,module,exports){\nvar ERROR, IGNORE, WARN;\n\nERROR = 'error';\n\nWARN = 'warn';\n\nIGNORE = 'ignore';\n\nmodule.exports = {\n  coffeescript_error: {\n    level: ERROR,\n    message: ''\n  }\n};\n\n\n},{}],9:[function(require,module,exports){\nvar ArrowSpacing;\n\nmodule.exports = ArrowSpacing = (function() {\n  function ArrowSpacing() {}\n\n  ArrowSpacing.prototype.rule = {\n    name: 'arrow_spacing',\n    level: 'ignore',\n    message: 'Function arrows (-> and =>) must be spaced properly',\n    description: '<p>This rule checks to see that there is spacing before and after\\nthe arrow operator that declares a function. This rule is disabled\\nby default.</p> <p>Note that if arrow_spacing is enabled, and you\\npass an empty function as a parameter, arrow_spacing will accept\\neither a space or no space in-between the arrow operator and the\\nparenthesis</p>\\n<pre><code># Both of this will not trigger an error,\\n# even with arrow_spacing enabled.\\nx(-> 3)\\nx( -> 3)\\n\\n# However, this will trigger an error\\nx((a,b)-> 3)\\n</code>\\n</pre>'\n  };\n\n  ArrowSpacing.prototype.tokens = ['->', '=>'];\n\n  ArrowSpacing.prototype.lintToken = function(token, tokenApi) {\n    var pp;\n    pp = tokenApi.peek(-1);\n    if (!pp) {\n      return;\n    }\n    if (!token.spaced && tokenApi.peek(1)[0] === 'INDENT' && tokenApi.peek(2)[0] === 'OUTDENT') {\n      return null;\n    } else if (!(((token.spaced != null) || (token.newLine != null)) && (((pp.spaced != null) || pp[0] === 'TERMINATOR') || (pp.generated != null) || pp[0] === 'INDENT' || (pp[1] === '(' && (pp.generated == null))))) {\n      return true;\n    } else {\n      return null;\n    }\n  };\n\n  return ArrowSpacing;\n\n})();\n\n\n},{}],10:[function(require,module,exports){\nvar BracesSpacing;\n\nmodule.exports = BracesSpacing = (function() {\n  function BracesSpacing() {}\n\n  BracesSpacing.prototype.rule = {\n    name: 'braces_spacing',\n    level: 'ignore',\n    spaces: 0,\n    empty_object_spaces: 0,\n    message: 'Curly braces must have the proper spacing',\n    description: 'This rule checks to see that there is the proper spacing inside\\ncurly braces. The spacing amount is specified by \"spaces\".\\nThe spacing amount for empty objects is specified by\\n\"empty_object_spaces\".\\n\\n<pre><code>\\n# Spaces is 0\\n{a: b}     # Good\\n{a: b }    # Bad\\n{ a: b}    # Bad\\n{ a: b }   # Bad\\n\\n# Spaces is 1\\n{a: b}     # Bad\\n{a: b }    # Bad\\n{ a: b}    # Bad\\n{ a: b }   # Good\\n{ a: b  }  # Bad\\n{  a: b }  # Bad\\n{  a: b  } # Bad\\n\\n# Empty Object Spaces is 0\\n{}         # Good\\n{ }        # Bad\\n\\n# Empty Object Spaces is 1\\n{}         # Bad\\n{ }        # Good\\n</code></pre>\\n\\nThis rule is disabled by default.'\n  };\n\n  BracesSpacing.prototype.tokens = ['{', '}'];\n\n  BracesSpacing.prototype.distanceBetweenTokens = function(firstToken, secondToken) {\n    return secondToken[2].first_column - firstToken[2].last_column - 1;\n  };\n\n  BracesSpacing.prototype.findNearestToken = function(token, tokenApi, difference) {\n    var nearestToken, totalDifference;\n    totalDifference = 0;\n    while (true) {\n      totalDifference += difference;\n      nearestToken = tokenApi.peek(totalDifference);\n      if (nearestToken[0] === 'OUTDENT' || (nearestToken.generated != null)) {\n        continue;\n      }\n      return nearestToken;\n    }\n  };\n\n  BracesSpacing.prototype.tokensOnSameLine = function(firstToken, secondToken) {\n    return firstToken[2].first_line === secondToken[2].first_line;\n  };\n\n  BracesSpacing.prototype.getExpectedSpaces = function(tokenApi, firstToken, secondToken) {\n    var config, ref;\n    config = tokenApi.config[this.rule.name];\n    if (firstToken[0] === '{' && secondToken[0] === '}') {\n      return (ref = config.empty_object_spaces) != null ? ref : config.spaces;\n    } else {\n      return config.spaces;\n    }\n  };\n\n  BracesSpacing.prototype.lintToken = function(token, tokenApi) {\n    var actual, expected, firstToken, msg, ref, secondToken;\n    if (token.generated) {\n      return null;\n    }\n    ref = token[0] === '{' ? [token, this.findNearestToken(token, tokenApi, 1)] : [this.findNearestToken(token, tokenApi, -1), token], firstToken = ref[0], secondToken = ref[1];\n    if (!this.tokensOnSameLine(firstToken, secondToken)) {\n      return null;\n    }\n    expected = this.getExpectedSpaces(tokenApi, firstToken, secondToken);\n    actual = this.distanceBetweenTokens(firstToken, secondToken);\n    if (actual === expected) {\n      return null;\n    } else {\n      msg = \"There should be \" + expected + \" space\";\n      if (expected !== 1) {\n        msg += 's';\n      }\n      msg += \" inside \\\"\" + token[0] + \"\\\"\";\n      return {\n        context: msg\n      };\n    }\n  };\n\n  return BracesSpacing;\n\n})();\n\n\n},{}],11:[function(require,module,exports){\nvar CamelCaseClasses, regexes;\n\nregexes = {\n  camelCase: /^[A-Z_][a-zA-Z\\d]*$/\n};\n\nmodule.exports = CamelCaseClasses = (function() {\n  function CamelCaseClasses() {}\n\n  CamelCaseClasses.prototype.rule = {\n    name: 'camel_case_classes',\n    level: 'error',\n    message: 'Class name should be UpperCamelCased',\n    description: 'This rule mandates that all class names are UpperCamelCased.\\nCamel casing class names is a generally accepted way of\\ndistinguishing constructor functions - which require the \\'new\\'\\nprefix to behave properly - from plain old functions.\\n<pre>\\n<code># Good!\\nclass BoaConstrictor\\n\\n# Bad!\\nclass boaConstrictor\\n</code>\\n</pre>\\nThis rule is enabled by default.'\n  };\n\n  CamelCaseClasses.prototype.tokens = ['CLASS'];\n\n  CamelCaseClasses.prototype.lintToken = function(token, tokenApi) {\n    var className, offset, ref, ref1, ref2;\n    if ((token.newLine != null) || ((ref = tokenApi.peek()[0]) === 'INDENT' || ref === 'EXTENDS')) {\n      return null;\n    }\n    className = null;\n    offset = 1;\n    while (!className) {\n      if (((ref1 = tokenApi.peek(offset + 1)) != null ? ref1[0] : void 0) === '.') {\n        offset += 2;\n      } else if (((ref2 = tokenApi.peek(offset)) != null ? ref2[0] : void 0) === '@') {\n        offset += 1;\n      } else {\n        className = tokenApi.peek(offset)[1];\n      }\n    }\n    if (!regexes.camelCase.test(className)) {\n      return {\n        context: \"class name: \" + className\n      };\n    }\n  };\n\n  return CamelCaseClasses;\n\n})();\n\n\n},{}],12:[function(require,module,exports){\nvar ColonAssignmentSpacing;\n\nmodule.exports = ColonAssignmentSpacing = (function() {\n  function ColonAssignmentSpacing() {}\n\n  ColonAssignmentSpacing.prototype.rule = {\n    name: 'colon_assignment_spacing',\n    level: 'ignore',\n    message: 'Colon assignment without proper spacing',\n    spacing: {\n      left: 0,\n      right: 0\n    },\n    description: '<p>This rule checks to see that there is spacing before and\\nafter the colon in a colon assignment (i.e., classes, objects).\\nThe spacing amount is specified by\\nspacing.left and spacing.right, respectively.\\nA zero value means no spacing required.\\n</p>\\n<pre><code>\\n#\\n# If spacing.left and spacing.right is 1\\n#\\n\\n# Doesn\\'t throw an error\\nobject = {spacing : true}\\nclass Dog\\n  canBark : true\\n\\n# Throws an error\\nobject = {spacing: true}\\nclass Cat\\n  canBark: false\\n</code></pre>'\n  };\n\n  ColonAssignmentSpacing.prototype.tokens = [':'];\n\n  ColonAssignmentSpacing.prototype.lintToken = function(token, tokenApi) {\n    var checkSpacing, getSpaceFromToken, isLeftSpaced, isRightSpaced, leftSpacing, nextToken, previousToken, ref, ref1, rightSpacing, spaceRules;\n    spaceRules = tokenApi.config[this.rule.name].spacing;\n    previousToken = tokenApi.peek(-1);\n    nextToken = tokenApi.peek(1);\n    getSpaceFromToken = function(direction) {\n      switch (direction) {\n        case 'left':\n          return token[2].first_column - previousToken[2].last_column - 1;\n        case 'right':\n          return nextToken[2].first_column - token[2].first_column - 1;\n      }\n    };\n    checkSpacing = function(direction) {\n      var isSpaced, spacing;\n      spacing = getSpaceFromToken(direction);\n      isSpaced = spacing < 0 ? true : spacing === parseInt(spaceRules[direction]);\n      return [isSpaced, spacing];\n    };\n    ref = checkSpacing('left'), isLeftSpaced = ref[0], leftSpacing = ref[1];\n    ref1 = checkSpacing('right'), isRightSpaced = ref1[0], rightSpacing = ref1[1];\n    if (isLeftSpaced && isRightSpaced) {\n      return null;\n    } else {\n      return {\n        context: \"Incorrect spacing around column \" + token[2].first_column\n      };\n    }\n  };\n\n  return ColonAssignmentSpacing;\n\n})();\n\n\n},{}],13:[function(require,module,exports){\nvar CyclomaticComplexity;\n\nmodule.exports = CyclomaticComplexity = (function() {\n  function CyclomaticComplexity() {}\n\n  CyclomaticComplexity.prototype.rule = {\n    name: 'cyclomatic_complexity',\n    level: 'ignore',\n    message: 'The cyclomatic complexity is too damn high',\n    value: 10,\n    description: 'Examine the complexity of your function.'\n  };\n\n  CyclomaticComplexity.prototype.getComplexity = function(node) {\n    var complexity, name, ref;\n    name = this.astApi.getNodeName(node);\n    complexity = name === 'If' || name === 'While' || name === 'For' || name === 'Try' ? 1 : name === 'Op' && ((ref = node.operator) === '&&' || ref === '||') ? 1 : name === 'Switch' ? node.cases.length : 0;\n    return complexity;\n  };\n\n  CyclomaticComplexity.prototype.lintAST = function(node, astApi) {\n    this.astApi = astApi;\n    this.lintNode(node);\n    return void 0;\n  };\n\n  CyclomaticComplexity.prototype.lintNode = function(node) {\n    var complexity, error, name, ref, rule;\n    name = (ref = this.astApi) != null ? ref.getNodeName(node) : void 0;\n    complexity = this.getComplexity(node);\n    node.eachChild((function(_this) {\n      return function(childNode) {\n        var childComplexity, ref1;\n        childComplexity = _this.lintNode(childNode);\n        if (((ref1 = _this.astApi) != null ? ref1.getNodeName(childNode) : void 0) !== 'Code') {\n          return complexity += childComplexity;\n        }\n      };\n    })(this));\n    rule = this.astApi.config[this.rule.name];\n    if (name === 'Code' && complexity >= rule.value) {\n      error = this.astApi.createError({\n        context: complexity + 1,\n        lineNumber: node.locationData.first_line + 1,\n        lineNumberEnd: node.locationData.last_line + 1\n      });\n      if (error) {\n        this.errors.push(error);\n      }\n    }\n    return complexity;\n  };\n\n  return CyclomaticComplexity;\n\n})();\n\n\n},{}],14:[function(require,module,exports){\nvar DuplicateKey;\n\nmodule.exports = DuplicateKey = (function() {\n  DuplicateKey.prototype.rule = {\n    name: 'duplicate_key',\n    level: 'error',\n    message: 'Duplicate key defined in object or class',\n    description: 'Prevents defining duplicate keys in object literals and classes'\n  };\n\n  DuplicateKey.prototype.tokens = ['IDENTIFIER', 'PROPERTY', '{', '}'];\n\n  function DuplicateKey() {\n    this.braceScopes = [];\n  }\n\n  DuplicateKey.prototype.lintToken = function(arg, tokenApi) {\n    var type;\n    type = arg[0];\n    if (type === '{' || type === '}') {\n      this.lintBrace.apply(this, arguments);\n      return void 0;\n    }\n    if (type === 'IDENTIFIER' || type === 'PROPERTY') {\n      return this.lintIdentifier.apply(this, arguments);\n    }\n  };\n\n  DuplicateKey.prototype.lintIdentifier = function(token, tokenApi) {\n    var key, nextToken, previousToken;\n    key = token[1];\n    if (this.currentScope == null) {\n      return null;\n    }\n    nextToken = tokenApi.peek(1);\n    if (nextToken[1] !== ':') {\n      return null;\n    }\n    previousToken = tokenApi.peek(-1);\n    if (previousToken[0] === '@') {\n      key = \"@\" + key;\n    }\n    key = \"identifier-\" + key;\n    if (this.currentScope[key]) {\n      return true;\n    } else {\n      this.currentScope[key] = token;\n      return null;\n    }\n  };\n\n  DuplicateKey.prototype.lintBrace = function(token) {\n    if (token[0] === '{') {\n      if (this.currentScope != null) {\n        this.braceScopes.push(this.currentScope);\n      }\n      this.currentScope = {};\n    } else {\n      this.currentScope = this.braceScopes.pop();\n    }\n    return null;\n  };\n\n  return DuplicateKey;\n\n})();\n\n\n},{}],15:[function(require,module,exports){\nvar EmptyConstructorNeedsParens;\n\nmodule.exports = EmptyConstructorNeedsParens = (function() {\n  function EmptyConstructorNeedsParens() {}\n\n  EmptyConstructorNeedsParens.prototype.rule = {\n    name: 'empty_constructor_needs_parens',\n    level: 'ignore',\n    message: 'Invoking a constructor without parens and without arguments',\n    description: 'Requires constructors with no parameters to include the parens'\n  };\n\n  EmptyConstructorNeedsParens.prototype.tokens = ['UNARY'];\n\n  EmptyConstructorNeedsParens.prototype.lintToken = function(token, tokenApi) {\n    var identIndex, isIdent, nextToken, peek, ref, ref1, ref2;\n    if (token[1] === 'new') {\n      peek = tokenApi.peek.bind(tokenApi);\n      identIndex = 1;\n      while (true) {\n        isIdent = (ref = (ref1 = peek(identIndex)) != null ? ref1[0] : void 0) === 'IDENTIFIER' || ref === 'PROPERTY';\n        nextToken = peek(identIndex + 1);\n        if (isIdent) {\n          if ((nextToken != null ? nextToken[0] : void 0) === '.') {\n            identIndex += 2;\n            continue;\n          }\n          if ((nextToken != null ? nextToken[0] : void 0) === 'INDEX_START') {\n            while (((ref2 = peek(identIndex)) != null ? ref2[0] : void 0) !== 'INDEX_END') {\n              identIndex++;\n            }\n            continue;\n          }\n        }\n        break;\n      }\n      if (isIdent && (nextToken != null)) {\n        return this.handleExpectedCallStart(nextToken);\n      }\n    }\n  };\n\n  EmptyConstructorNeedsParens.prototype.handleExpectedCallStart = function(isCallStart) {\n    if (isCallStart[0] !== 'CALL_START') {\n      return true;\n    }\n  };\n\n  return EmptyConstructorNeedsParens;\n\n})();\n\n\n},{}],16:[function(require,module,exports){\nvar EnsureComprehensions,\n  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\nmodule.exports = EnsureComprehensions = (function() {\n  function EnsureComprehensions() {}\n\n  EnsureComprehensions.prototype.rule = {\n    name: 'ensure_comprehensions',\n    level: 'warn',\n    message: 'Comprehensions must have parentheses around them',\n    description: 'This rule makes sure that parentheses are around comprehensions.'\n  };\n\n  EnsureComprehensions.prototype.tokens = ['FOR'];\n\n  EnsureComprehensions.prototype.forBlock = false;\n\n  EnsureComprehensions.prototype.lintToken = function(token, tokenApi) {\n    var atEqual, idents, numCallEnds, numCallStarts, numParenEnds, numParenStarts, peeker, prevIdents, prevToken, ref, ref1;\n    idents = this.findIdents(tokenApi);\n    if (this.forBlock) {\n      this.forBlock = false;\n      return;\n    }\n    peeker = -1;\n    atEqual = false;\n    numCallEnds = 0;\n    numCallStarts = 0;\n    numParenStarts = 0;\n    numParenEnds = 0;\n    prevIdents = [];\n    while ((prevToken = tokenApi.peek(peeker))) {\n      if (prevToken[0] === 'CALL_END') {\n        numCallEnds++;\n      }\n      if (prevToken[0] === 'CALL_START') {\n        numCallStarts++;\n      }\n      if (prevToken[0] === '(') {\n        numParenStarts++;\n      }\n      if (prevToken[0] === ')') {\n        numParenEnds++;\n      }\n      if (prevToken[0] === 'IDENTIFIER') {\n        if (!atEqual) {\n          prevIdents.push(prevToken[1]);\n        } else if (ref = prevToken[1], indexOf.call(idents, ref) >= 0) {\n          return;\n        }\n      }\n      if (((ref1 = prevToken[0]) === '(' || ref1 === '->' || ref1 === 'TERMINATOR') || (prevToken.newLine != null)) {\n        break;\n      }\n      if (prevToken[0] === '=' && numParenEnds === numParenStarts) {\n        atEqual = true;\n      }\n      peeker--;\n    }\n    if (atEqual && numCallStarts === numCallEnds) {\n      return {\n        context: ''\n      };\n    }\n  };\n\n  EnsureComprehensions.prototype.findIdents = function(tokenApi) {\n    var idents, nextToken, peeker, ref;\n    peeker = 1;\n    idents = [];\n    while ((nextToken = tokenApi.peek(peeker))) {\n      if (nextToken[0] === 'IDENTIFIER') {\n        idents.push(nextToken[1]);\n      }\n      if ((ref = nextToken[0]) === 'FORIN' || ref === 'FOROF') {\n        break;\n      }\n      peeker++;\n    }\n    while ((nextToken = tokenApi.peek(peeker))) {\n      if (nextToken[0] === 'TERMINATOR') {\n        break;\n      }\n      if (nextToken[0] === 'INDENT') {\n        this.forBlock = true;\n        break;\n      }\n      peeker++;\n    }\n    return idents;\n  };\n\n  return EnsureComprehensions;\n\n})();\n\n\n},{}],17:[function(require,module,exports){\nvar EOLLast;\n\nmodule.exports = EOLLast = (function() {\n  function EOLLast() {}\n\n  EOLLast.prototype.rule = {\n    name: 'eol_last',\n    level: 'ignore',\n    message: 'File does not end with a single newline',\n    description: 'Checks that the file ends with a single newline'\n  };\n\n  EOLLast.prototype.lintLine = function(line, lineApi) {\n    var isNewline, previousIsNewline;\n    if (!lineApi.isLastLine()) {\n      return null;\n    }\n    isNewline = line.length === 0;\n    previousIsNewline = lineApi.lineCount > 1 ? lineApi.lines[lineApi.lineNumber - 1].length === 0 : false;\n    if (!(isNewline && !previousIsNewline)) {\n      return true;\n    }\n  };\n\n  return EOLLast;\n\n})();\n\n\n},{}],18:[function(require,module,exports){\nvar Indentation,\n  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\nmodule.exports = Indentation = (function() {\n  Indentation.prototype.rule = {\n    name: 'indentation',\n    value: 2,\n    level: 'error',\n    message: 'Line contains inconsistent indentation',\n    description: 'This rule imposes a standard number of spaces to be used for\\nindentation. Since whitespace is significant in CoffeeScript, it\\'s\\ncritical that a project chooses a standard indentation format and\\nstays consistent. Other roads lead to darkness. <pre> <code>#\\nEnabling this option will prevent this ugly\\n# but otherwise valid CoffeeScript.\\ntwoSpaces = () ->\\n  fourSpaces = () ->\\n      eightSpaces = () ->\\n            \\'this is valid CoffeeScript\\'\\n\\n</code>\\n</pre>\\nTwo space indentation is enabled by default.'\n  };\n\n  Indentation.prototype.tokens = ['INDENT', '[', ']', '.'];\n\n  Indentation.prototype.keywords = ['->', '=>', '@', 'CATCH', 'CLASS', 'ELSE', 'FINALLY', 'FOR', 'FORIN', 'FOROF', 'IDENTIFIER', 'IF', 'LEADING_WHEN', 'LOOP', 'RETURN', 'SWITCH', 'THROW', 'TRY', 'UNTIL', 'WHEN', 'WHILE', 'YIELD'];\n\n  function Indentation() {\n    this.arrayTokens = [];\n  }\n\n  Indentation.prototype.lintToken = function(token, tokenApi) {\n    var currentLine, expected, ignoreIndent, isArrayIndent, isMultiline, lineNumber, lines, numIndents, previous, previousSymbol, ref, ref1, ref2, type;\n    type = token[0], numIndents = token[1], (ref = token[2], lineNumber = ref.first_line);\n    lines = tokenApi.lines, lineNumber = tokenApi.lineNumber;\n    expected = tokenApi.config[this.rule.name].value;\n    if (type === '.') {\n      currentLine = lines[lineNumber];\n      if (((ref1 = currentLine.match(/\\S/)) != null ? ref1[0] : void 0) === '.') {\n        return this.handleChain(tokenApi, expected);\n      }\n      return void 0;\n    }\n    if (type === '[' || type === ']') {\n      this.lintArray(token);\n      return void 0;\n    }\n    if ((token.generated != null) || (token.explicit != null)) {\n      return null;\n    }\n    previous = tokenApi.peek(-1);\n    isArrayIndent = this.inArray() && (previous != null ? previous.newLine : void 0);\n    previousSymbol = (ref2 = tokenApi.peek(-1)) != null ? ref2[0] : void 0;\n    isMultiline = previousSymbol === '=' || previousSymbol === ',';\n    ignoreIndent = isArrayIndent || isMultiline;\n    numIndents = this.getCorrectIndent(tokenApi);\n    if (!ignoreIndent && !(indexOf.call(numIndents, expected) >= 0)) {\n      return {\n        context: \"Expected \" + expected + \" got \" + numIndents[0]\n      };\n    }\n  };\n\n  Indentation.prototype.inArray = function() {\n    return this.arrayTokens.length > 0;\n  };\n\n  Indentation.prototype.lintArray = function(token) {\n    if (token[0] === '[') {\n      this.arrayTokens.push(token);\n    } else if (token[0] === ']') {\n      this.arrayTokens.pop();\n    }\n    return null;\n  };\n\n  Indentation.prototype.handleChain = function(tokenApi, expected) {\n    var callStart, checkNum, currIsIndent, currentLine, currentSpaces, findCallStart, lastCheck, lineNumber, lines, numIndents, prevIsIndent, prevLine, prevNum, prevSpaces, ref, ref1;\n    lastCheck = 1;\n    callStart = 1;\n    prevNum = 1;\n    lineNumber = tokenApi.lineNumber, lines = tokenApi.lines;\n    currentLine = lines[lineNumber];\n    findCallStart = tokenApi.peek(-callStart);\n    while (findCallStart && findCallStart[0] !== 'TERMINATOR') {\n      lastCheck = findCallStart[2].first_line;\n      callStart += 1;\n      findCallStart = tokenApi.peek(-callStart);\n    }\n    while ((lineNumber - prevNum > lastCheck) && !/^\\s*\\./.test(lines[lineNumber - prevNum])) {\n      prevNum += 1;\n    }\n    checkNum = lineNumber - prevNum;\n    if (checkNum >= 0) {\n      prevLine = lines[checkNum];\n      if (prevLine.match(/\\S/)[0] === '.' || checkNum === lastCheck) {\n        currentSpaces = (ref = currentLine.match(/\\S/)) != null ? ref.index : void 0;\n        prevSpaces = (ref1 = prevLine.match(/\\S/)) != null ? ref1.index : void 0;\n        numIndents = currentSpaces - prevSpaces;\n        prevIsIndent = prevSpaces % expected !== 0;\n        currIsIndent = currentSpaces % expected !== 0;\n        if (prevIsIndent && currIsIndent) {\n          numIndents = currentSpaces;\n        }\n        if (numIndents % expected !== 0) {\n          return {\n            context: \"Expected \" + expected + \" got \" + numIndents\n          };\n        }\n      }\n    }\n  };\n\n  Indentation.prototype.grabLineTokens = function(tokenApi, lineNumber, all) {\n    var i, k, len, len1, ref, ref1, results, results1, tok, tokensByLine;\n    if (all == null) {\n      all = false;\n    }\n    tokensByLine = tokenApi.tokensByLine;\n    while (!((tokensByLine[lineNumber] != null) || lineNumber === 0)) {\n      lineNumber--;\n    }\n    if (all) {\n      ref = tokensByLine[lineNumber];\n      results = [];\n      for (i = 0, len = ref.length; i < len; i++) {\n        tok = ref[i];\n        results.push(tok);\n      }\n      return results;\n    } else {\n      ref1 = tokensByLine[lineNumber];\n      results1 = [];\n      for (k = 0, len1 = ref1.length; k < len1; k++) {\n        tok = ref1[k];\n        if ((tok.generated == null) && tok[0] !== 'OUTDENT') {\n          results1.push(tok);\n        }\n      }\n      return results1;\n    }\n  };\n\n  Indentation.prototype.getCorrectIndent = function(tokenApi) {\n    var _, curIndent, i, j, len, lineNumber, lines, prevIndent, prevNum, prevTokens, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ret, skipAssign, t, tokens, tryLine;\n    lineNumber = tokenApi.lineNumber, lines = tokenApi.lines, tokens = tokenApi.tokens;\n    curIndent = (ref = lines[lineNumber].match(/\\S/)) != null ? ref.index : void 0;\n    prevNum = 1;\n    while (/^\\s*(#|$)/.test(lines[lineNumber - prevNum])) {\n      prevNum += 1;\n    }\n    prevTokens = this.grabLineTokens(tokenApi, lineNumber - prevNum);\n    if (((ref1 = prevTokens[0]) != null ? ref1[0] : void 0) === 'INDENT') {\n      return [curIndent - ((ref2 = prevTokens[1]) != null ? ref2[2].first_column : void 0), curIndent - prevTokens[0][1]];\n    } else {\n      prevIndent = (ref3 = prevTokens[0]) != null ? ref3[2].first_column : void 0;\n      for (j = i = 0, len = prevTokens.length; i < len; j = ++i) {\n        _ = prevTokens[j];\n        if (!(prevTokens[j][0] === '=' && ((ref4 = prevTokens[j + 1]) != null ? ref4[0] : void 0) === 'IF')) {\n          continue;\n        }\n        skipAssign = curIndent - prevTokens[j + 1][2].first_column;\n        ret = curIndent - prevIndent;\n        if (skipAssign < 0) {\n          return [ret];\n        }\n        return [skipAssign, ret];\n      }\n      while (prevIndent > curIndent) {\n        tryLine = lineNumber - prevNum;\n        prevTokens = this.grabLineTokens(tokenApi, tryLine, true);\n        if (((ref5 = prevTokens[0]) != null ? ref5[0] : void 0) === 'INDENT') {\n          prevIndent = prevTokens[0][1];\n          prevTokens = prevTokens.slice(1);\n        }\n        t = 0;\n        while (!((prevTokens[t] == null) || (ref6 = prevTokens[t][0], indexOf.call(this.keywords, ref6) >= 0))) {\n          t++;\n        }\n        prevTokens = prevTokens.slice(t);\n        prevNum++;\n        if (prevTokens[0] == null) {\n          continue;\n        }\n        prevIndent = (ref7 = prevTokens[0]) != null ? ref7[2].first_column : void 0;\n      }\n    }\n    return [curIndent - prevIndent];\n  };\n\n  return Indentation;\n\n})();\n\n\n},{}],19:[function(require,module,exports){\nvar LineEndings;\n\nmodule.exports = LineEndings = (function() {\n  function LineEndings() {}\n\n  LineEndings.prototype.rule = {\n    name: 'line_endings',\n    level: 'ignore',\n    value: 'unix',\n    message: 'Line contains incorrect line endings',\n    description: 'This rule ensures your project uses only <tt>windows</tt> or\\n<tt>unix</tt> line endings. This rule is disabled by default.'\n  };\n\n  LineEndings.prototype.lintLine = function(line, lineApi) {\n    var ending, lastChar, ref, valid;\n    ending = (ref = lineApi.config[this.rule.name]) != null ? ref.value : void 0;\n    if (!ending || lineApi.isLastLine() || !line) {\n      return null;\n    }\n    lastChar = line[line.length - 1];\n    valid = (function() {\n      if (ending === 'windows') {\n        return lastChar === '\\r';\n      } else if (ending === 'unix') {\n        return lastChar !== '\\r';\n      } else {\n        throw new Error(\"unknown line ending type: \" + ending);\n      }\n    })();\n    if (!valid) {\n      return {\n        context: \"Expected \" + ending\n      };\n    } else {\n      return null;\n    }\n  };\n\n  return LineEndings;\n\n})();\n\n\n},{}],20:[function(require,module,exports){\nvar MaxLineLength, regexes;\n\nregexes = {\n  literateComment: /^\\#\\s/,\n  longUrlComment: /^\\s*\\#\\s*http[^\\s]+$/\n};\n\nmodule.exports = MaxLineLength = (function() {\n  function MaxLineLength() {}\n\n  MaxLineLength.prototype.rule = {\n    name: 'max_line_length',\n    value: 80,\n    level: 'error',\n    limitComments: true,\n    message: 'Line exceeds maximum allowed length',\n    description: 'This rule imposes a maximum line length on your code. <a\\nhref=\"http://www.python.org/dev/peps/pep-0008/\">Python\\'s style\\nguide</a> does a good job explaining why you might want to limit the\\nlength of your lines, though this is a matter of taste.\\n\\nLines can be no longer than eighty characters by default.'\n  };\n\n  MaxLineLength.prototype.lintLine = function(line, lineApi) {\n    var limitComments, lineLength, max, ref, ref1;\n    max = (ref = lineApi.config[this.rule.name]) != null ? ref.value : void 0;\n    limitComments = (ref1 = lineApi.config[this.rule.name]) != null ? ref1.limitComments : void 0;\n    lineLength = line.replace(/\\s+$/, '').length;\n    if (lineApi.isLiterate() && regexes.literateComment.test(line)) {\n      lineLength -= 2;\n    }\n    if (max && max < lineLength && !regexes.longUrlComment.test(line)) {\n      if (!limitComments) {\n        if (lineApi.getLineTokens().length === 0) {\n          return;\n        }\n      }\n      return {\n        context: \"Length is \" + lineLength + \", max is \" + max\n      };\n    }\n  };\n\n  return MaxLineLength;\n\n})();\n\n\n},{}],21:[function(require,module,exports){\nvar MissingFatArrows, any, containsButIsnt,\n  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\nany = function(arr, test) {\n  return arr.reduce((function(res, elt) {\n    return res || test(elt);\n  }), false);\n};\n\ncontainsButIsnt = function(node, nIsThis, nIsClass) {\n  var target;\n  target = void 0;\n  node.traverseChildren(false, function(n) {\n    if (nIsClass(n)) {\n      return false;\n    }\n    if (nIsThis(n)) {\n      target = n;\n      return false;\n    }\n  });\n  return target;\n};\n\nmodule.exports = MissingFatArrows = (function() {\n  function MissingFatArrows() {\n    this.isFatArrowCode = bind(this.isFatArrowCode, this);\n    this.isThis = bind(this.isThis, this);\n    this.isObject = bind(this.isObject, this);\n    this.isValue = bind(this.isValue, this);\n    this.isClass = bind(this.isClass, this);\n    this.isCode = bind(this.isCode, this);\n  }\n\n  MissingFatArrows.prototype.rule = {\n    name: 'missing_fat_arrows',\n    level: 'ignore',\n    is_strict: false,\n    message: 'Used `this` in a function without a fat arrow',\n    description: 'Warns when you use `this` inside a function that wasn\\'t defined\\nwith a fat arrow. This rule does not apply to methods defined in a\\nclass, since they have `this` bound to the class instance (or the\\nclass itself, for class methods). The option `is_strict` is\\navailable for checking bindings of class methods.\\n\\nIt is impossible to statically determine whether a function using\\n`this` will be bound with the correct `this` value due to language\\nfeatures like `Function.prototype.call` and\\n`Function.prototype.bind`, so this rule may produce false positives.'\n  };\n\n  MissingFatArrows.prototype.lintAST = function(node, astApi) {\n    this.astApi = astApi;\n    this.lintNode(node);\n    return void 0;\n  };\n\n  MissingFatArrows.prototype.lintNode = function(node, methods) {\n    var error, isStrict, ref;\n    if (methods == null) {\n      methods = [];\n    }\n    isStrict = (ref = this.astApi.config[this.rule.name]) != null ? ref.is_strict : void 0;\n    if (this.isPrototype(node)) {\n      return;\n    }\n    if (this.isConstructor(node)) {\n      return;\n    }\n    if ((!this.isFatArrowCode(node)) && (isStrict ? true : indexOf.call(methods, node) < 0) && (this.needsFatArrow(node))) {\n      error = this.astApi.createError({\n        lineNumber: node.locationData.first_line + 1\n      });\n      this.errors.push(error);\n    }\n    return node.eachChild((function(_this) {\n      return function(child) {\n        return _this.lintNode(child, (function() {\n          switch (false) {\n            case !this.isClass(node):\n              return this.methodsOfClass(node);\n            case !this.isCode(node):\n              return [];\n            default:\n              return methods;\n          }\n        }).call(_this));\n      };\n    })(this));\n  };\n\n  MissingFatArrows.prototype.isCode = function(node) {\n    return this.astApi.getNodeName(node) === 'Code';\n  };\n\n  MissingFatArrows.prototype.isClass = function(node) {\n    return this.astApi.getNodeName(node) === 'Class';\n  };\n\n  MissingFatArrows.prototype.isValue = function(node) {\n    return this.astApi.getNodeName(node) === 'Value';\n  };\n\n  MissingFatArrows.prototype.isObject = function(node) {\n    return this.astApi.getNodeName(node) === 'Obj';\n  };\n\n  MissingFatArrows.prototype.isPrototype = function(node) {\n    var i, ident, len, props, ref, ref1;\n    props = (node != null ? (ref = node.variable) != null ? ref.properties : void 0 : void 0) || [];\n    for (i = 0, len = props.length; i < len; i++) {\n      ident = props[i];\n      if (((ref1 = ident.name) != null ? ref1.value : void 0) === 'prototype') {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  MissingFatArrows.prototype.isThis = function(node) {\n    return this.isValue(node) && node.base.value === 'this';\n  };\n\n  MissingFatArrows.prototype.isFatArrowCode = function(node) {\n    return this.isCode(node) && node.bound;\n  };\n\n  MissingFatArrows.prototype.isConstructor = function(node) {\n    var ref, ref1;\n    return ((ref = node.variable) != null ? (ref1 = ref.base) != null ? ref1.value : void 0 : void 0) === 'constructor';\n  };\n\n  MissingFatArrows.prototype.needsFatArrow = function(node) {\n    return this.isCode(node) && (any(node.params, (function(_this) {\n      return function(param) {\n        return param.contains(_this.isThis) != null;\n      };\n    })(this)) || containsButIsnt(node.body, this.isThis, this.isClass));\n  };\n\n  MissingFatArrows.prototype.methodsOfClass = function(classNode) {\n    var bodyNodes, returnNode;\n    bodyNodes = classNode.body.expressions;\n    returnNode = bodyNodes[bodyNodes.length - 1];\n    if ((returnNode != null) && this.isValue(returnNode) && this.isObject(returnNode.base)) {\n      return returnNode.base.properties.map(function(assignNode) {\n        return assignNode.value;\n      }).filter(this.isCode);\n    } else {\n      return [];\n    }\n  };\n\n  return MissingFatArrows;\n\n})();\n\n\n},{}],22:[function(require,module,exports){\nvar NewlinesAfterClasses;\n\nmodule.exports = NewlinesAfterClasses = (function() {\n  function NewlinesAfterClasses() {}\n\n  NewlinesAfterClasses.prototype.rule = {\n    name: 'newlines_after_classes',\n    value: 3,\n    level: 'ignore',\n    message: 'Wrong count of newlines between a class and other code',\n    description: '<p>Checks the number of newlines between classes and other code.</p>\\n\\nOptions:\\n- <pre><code>value</code></pre> - The number of required newlines\\nafter class definitions. Defaults to 3.'\n  };\n\n  NewlinesAfterClasses.prototype.tokens = ['CLASS', '}', '{'];\n\n  NewlinesAfterClasses.prototype.classBracesCount = 0;\n\n  NewlinesAfterClasses.prototype.classCount = 0;\n\n  NewlinesAfterClasses.prototype.lintToken = function(token, tokenApi) {\n    var afters, befores, comment, ending, got, lineNumber, lines, numIndents, outdent, ref, ref1, ref2, start, trueLine, type;\n    type = token[0], numIndents = token[1], (ref = token[2], lineNumber = ref.first_line);\n    lines = tokenApi.lines;\n    ending = tokenApi.config[this.rule.name].value;\n    if (type === 'CLASS') {\n      this.classCount++;\n    }\n    if (this.classCount > 0 && (token.generated != null)) {\n      if (type === '{' && ((ref1 = token.origin) != null ? ref1[0] : void 0) === ':') {\n        this.classBracesCount++;\n      }\n      if (type === '}' && ((ref2 = token.origin) != null ? ref2[0] : void 0) === 'OUTDENT') {\n        this.classBracesCount--;\n        this.classCount--;\n        if (this.classCount === 0 && this.classBracesCount === 0) {\n          befores = 1;\n          afters = 1;\n          comment = 0;\n          outdent = token.origin[2].first_line;\n          start = Math.min(lineNumber, outdent);\n          trueLine = 2e308;\n          while (/^\\s*(#|$)/.test(lines[start + afters])) {\n            if (/^\\s*#/.test(lines[start + afters])) {\n              comment += 1;\n            } else {\n              trueLine = Math.min(trueLine, start + afters);\n            }\n            afters += 1;\n          }\n          while (/^\\s*(#|$)/.test(lines[start - befores])) {\n            if (/^\\s*#/.test(lines[start - befores])) {\n              comment += 1;\n            } else {\n              trueLine = Math.min(trueLine, start - befores);\n            }\n            befores += 1;\n          }\n          got = afters + befores - comment - 2;\n          if (got !== ending && trueLine + ending <= lines.length) {\n            return {\n              context: \"Expected \" + ending + \" got \" + got,\n              lineNumber: trueLine\n            };\n          }\n        }\n      }\n    }\n  };\n\n  return NewlinesAfterClasses;\n\n})();\n\n\n},{}],23:[function(require,module,exports){\nvar NoBackticks;\n\nmodule.exports = NoBackticks = (function() {\n  function NoBackticks() {}\n\n  NoBackticks.prototype.rule = {\n    name: 'no_backticks',\n    level: 'error',\n    message: 'Backticks are forbidden',\n    description: 'Backticks allow snippets of JavaScript to be embedded in\\nCoffeeScript. While some folks consider backticks useful in a few\\nniche circumstances, they should be avoided because so none of\\nJavaScript\\'s \"bad parts\", like <tt>with</tt> and <tt>eval</tt>,\\nsneak into CoffeeScript.\\nThis rule is enabled by default.'\n  };\n\n  NoBackticks.prototype.tokens = ['JS'];\n\n  NoBackticks.prototype.lintToken = function(token, tokenApi) {\n    return true;\n  };\n\n  return NoBackticks;\n\n})();\n\n\n},{}],24:[function(require,module,exports){\nvar NoDebugger;\n\nmodule.exports = NoDebugger = (function() {\n  function NoDebugger() {}\n\n  NoDebugger.prototype.rule = {\n    name: 'no_debugger',\n    level: 'warn',\n    message: 'Found debugging code',\n    console: false,\n    description: 'This rule detects `debugger` and optionally `console` calls\\nThis rule is `warn` by default.'\n  };\n\n  NoDebugger.prototype.tokens = ['STATEMENT', 'DEBUGGER', 'IDENTIFIER'];\n\n  NoDebugger.prototype.lintToken = function(token, tokenApi) {\n    var method, ref, ref1, ref2;\n    if (((ref = token[0]) === 'DEBUGGER' || ref === 'STATEMENT') && token[1] === 'debugger') {\n      return {\n        context: \"found '\" + token[0] + \"'\"\n      };\n    }\n    if ((ref1 = tokenApi.config[this.rule.name]) != null ? ref1.console : void 0) {\n      if (token[1] === 'console' && ((ref2 = tokenApi.peek(1)) != null ? ref2[0] : void 0) === '.') {\n        method = tokenApi.peek(2);\n        return {\n          context: \"found 'console.\" + method[1] + \"'\"\n        };\n      }\n    }\n  };\n\n  return NoDebugger;\n\n})();\n\n\n},{}],25:[function(require,module,exports){\nvar NoEmptyFunctions, isEmptyCode;\n\nisEmptyCode = function(node, astApi) {\n  var nodeName;\n  nodeName = astApi.getNodeName(node);\n  return nodeName === 'Code' && node.body.isEmpty();\n};\n\nmodule.exports = NoEmptyFunctions = (function() {\n  function NoEmptyFunctions() {}\n\n  NoEmptyFunctions.prototype.rule = {\n    name: 'no_empty_functions',\n    level: 'ignore',\n    message: 'Empty function',\n    description: 'Disallows declaring empty functions. The goal of this rule is that\\nunintentional empty callbacks can be detected:\\n<pre>\\n<code>someFunctionWithCallback ->\\ndoSomethingSignificant()\\n</code>\\n</pre>\\nThe problem is that the call to\\n<tt>doSomethingSignificant</tt> will be made regardless\\nof <tt>someFunctionWithCallback</tt>\\'s execution. It can\\nbe because you did not indent the call to\\n<tt>doSomethingSignificant</tt> properly.\\n\\nIf you really meant that <tt>someFunctionWithCallback</tt>\\nshould call a callback that does nothing, you can write your code\\nthis way:\\n<pre>\\n<code>someFunctionWithCallback ->\\n    undefined\\ndoSomethingSignificant()\\n</code>\\n</pre>'\n  };\n\n  NoEmptyFunctions.prototype.lintAST = function(node, astApi) {\n    this.lintNode(node, astApi);\n    return void 0;\n  };\n\n  NoEmptyFunctions.prototype.lintNode = function(node, astApi) {\n    var error;\n    if (isEmptyCode(node, astApi)) {\n      error = astApi.createError({\n        lineNumber: node.locationData.first_line + 1\n      });\n      this.errors.push(error);\n    }\n    return node.eachChild((function(_this) {\n      return function(child) {\n        return _this.lintNode(child, astApi);\n      };\n    })(this));\n  };\n\n  return NoEmptyFunctions;\n\n})();\n\n\n},{}],26:[function(require,module,exports){\nvar NoEmptyParamList;\n\nmodule.exports = NoEmptyParamList = (function() {\n  function NoEmptyParamList() {}\n\n  NoEmptyParamList.prototype.rule = {\n    name: 'no_empty_param_list',\n    level: 'ignore',\n    message: 'Empty parameter list is forbidden',\n    description: 'This rule prohibits empty parameter lists in function definitions.\\n<pre>\\n<code># The empty parameter list in here is unnecessary:\\nmyFunction = () -&gt;\\n\\n# We might favor this instead:\\nmyFunction = -&gt;\\n</code>\\n</pre>\\nEmpty parameter lists are permitted by default.'\n  };\n\n  NoEmptyParamList.prototype.tokens = ['PARAM_START'];\n\n  NoEmptyParamList.prototype.lintToken = function(token, tokenApi) {\n    var nextType;\n    nextType = tokenApi.peek()[0];\n    return nextType === 'PARAM_END';\n  };\n\n  return NoEmptyParamList;\n\n})();\n\n\n},{}],27:[function(require,module,exports){\nvar NoImplicitBraces;\n\nmodule.exports = NoImplicitBraces = (function() {\n  NoImplicitBraces.prototype.rule = {\n    name: 'no_implicit_braces',\n    level: 'ignore',\n    message: 'Implicit braces are forbidden',\n    strict: true,\n    description: 'This rule prohibits implicit braces when declaring object literals.\\nImplicit braces can make code more difficult to understand,\\nespecially when used in combination with optional parenthesis.\\n<pre>\\n<code># Do you find this code ambiguous? Is it a\\n# function call with three arguments or four?\\nmyFunction a, b, 1:2, 3:4\\n\\n# While the same code written in a more\\n# explicit manner has no ambiguity.\\nmyFunction(a, b, {1:2, 3:4})\\n</code>\\n</pre>\\nImplicit braces are permitted by default, since their use is\\nidiomatic CoffeeScript.'\n  };\n\n  NoImplicitBraces.prototype.tokens = ['{', 'OUTDENT', 'CLASS', 'IDENTIFIER', 'EXTENDS'];\n\n  function NoImplicitBraces() {\n    this.isClass = false;\n    this.className = '';\n  }\n\n  NoImplicitBraces.prototype.lintToken = function(token, tokenApi) {\n    var _type, _val, c, lineNum, peekIdent, prevToken, ref, ref1, type, val;\n    type = token[0], val = token[1], lineNum = token[2];\n    if (type === 'OUTDENT' || type === 'CLASS') {\n      return this.trackClass.apply(this, arguments);\n    }\n    if (type === 'EXTENDS') {\n      this.className = '';\n      return;\n    }\n    if (type === 'IDENTIFIER' && this.isClass && this.className === '') {\n      c = 0;\n      while ((ref = tokenApi.peek(c)[0]) === 'IDENTIFIER' || ref === 'PROPERTY' || ref === '.') {\n        this.className += tokenApi.peek(c)[1];\n        c++;\n      }\n    }\n    if (token.generated && type === '{') {\n      if (!tokenApi.config[this.rule.name].strict) {\n        prevToken = tokenApi.peek(-1)[0];\n        if (prevToken === 'INDENT' || prevToken === 'TERMINATOR') {\n          return;\n        }\n      }\n      if (this.isClass) {\n        prevToken = tokenApi.peek(-1)[0];\n        if (prevToken === 'TERMINATOR') {\n          return;\n        }\n        peekIdent = '';\n        c = -2;\n        while ((ref1 = tokenApi.peek(c), _type = ref1[0], _val = ref1[1], ref1)) {\n          if (_type !== 'IDENTIFIER' && _type !== 'PROPERTY' && _type !== '.') {\n            break;\n          }\n          peekIdent = _val + peekIdent;\n          c--;\n        }\n        if (peekIdent === this.className) {\n          return;\n        }\n      }\n      return true;\n    }\n  };\n\n  NoImplicitBraces.prototype.trackClass = function(token, tokenApi) {\n    var ln, n0, n1, ref, ref1, ref2;\n    ref = [token, tokenApi.peek()], (ref1 = ref[0], n0 = ref1[0], ln = ref1[ref1.length - 1]), (ref2 = ref[1], n1 = ref2[0]);\n    if (n0 === 'OUTDENT' && n1 === 'TERMINATOR') {\n      this.isClass = false;\n    }\n    if (n0 === 'CLASS') {\n      this.isClass = true;\n      this.className = '';\n    }\n    return null;\n  };\n\n  return NoImplicitBraces;\n\n})();\n\n\n},{}],28:[function(require,module,exports){\nvar NoImplicitParens;\n\nmodule.exports = NoImplicitParens = (function() {\n  function NoImplicitParens() {}\n\n  NoImplicitParens.prototype.rule = {\n    name: 'no_implicit_parens',\n    level: 'ignore',\n    message: 'Implicit parens are forbidden',\n    strict: true,\n    description: 'This rule prohibits implicit parens on function calls.\\n<pre>\\n<code># Some folks don\\'t like this style of coding.\\nmyFunction a, b, c\\n\\n# And would rather it always be written like this:\\nmyFunction(a, b, c)\\n</code>\\n</pre>\\nImplicit parens are permitted by default, since their use is\\nidiomatic CoffeeScript.'\n  };\n\n  NoImplicitParens.prototype.tokens = ['CALL_END'];\n\n  NoImplicitParens.prototype.lintToken = function(token, tokenApi) {\n    var i, t;\n    if (token.generated) {\n      if (tokenApi.config[this.rule.name].strict !== false) {\n        return true;\n      } else {\n        i = -1;\n        while (true) {\n          t = tokenApi.peek(i);\n          if ((t == null) || (t[0] === 'CALL_START' && t.generated)) {\n            return true;\n          }\n          if (t[2].first_line !== token[2].first_line) {\n            return null;\n          }\n          i -= 1;\n        }\n      }\n    }\n  };\n\n  return NoImplicitParens;\n\n})();\n\n\n},{}],29:[function(require,module,exports){\nvar NoInterpolationInSingleQuotes;\n\nmodule.exports = NoInterpolationInSingleQuotes = (function() {\n  function NoInterpolationInSingleQuotes() {}\n\n  NoInterpolationInSingleQuotes.prototype.rule = {\n    name: 'no_interpolation_in_single_quotes',\n    level: 'ignore',\n    message: 'Interpolation in single quoted strings is forbidden',\n    description: 'This rule prohibits string interpolation in a single quoted string.\\n<pre>\\n<code># String interpolation in single quotes is not allowed:\\nfoo = \\'#{bar}\\'\\n\\n# Double quotes is OK of course\\nfoo = \"#{bar}\"\\n</code>\\n</pre>\\nString interpolation in single quoted strings is permitted by\\ndefault.'\n  };\n\n  NoInterpolationInSingleQuotes.prototype.tokens = ['STRING'];\n\n  NoInterpolationInSingleQuotes.prototype.lintToken = function(token, tokenApi) {\n    var hasInterpolation, tokenValue;\n    tokenValue = token[1];\n    hasInterpolation = tokenValue.match(/^\\'.*#\\{[^}]+\\}.*\\'$/);\n    return hasInterpolation;\n  };\n\n  return NoInterpolationInSingleQuotes;\n\n})();\n\n\n},{}],30:[function(require,module,exports){\nvar NoNestedStringInterpolation;\n\nmodule.exports = NoNestedStringInterpolation = (function() {\n  NoNestedStringInterpolation.prototype.rule = {\n    name: 'no_nested_string_interpolation',\n    level: 'warn',\n    message: 'Nested string interpolation is forbidden',\n    description: 'This rule warns about nested string interpolation,\\nas it tends to make code harder to read and understand.\\n<pre>\\n<code># Good!\\nstr = \"Book by #{firstName.toUpperCase()} #{lastName.toUpperCase()}\"\\n\\n# Bad!\\nstr = \"Book by #{\"#{firstName} #{lastName}\".toUpperCase()}\"\\n</code>\\n</pre>'\n  };\n\n  NoNestedStringInterpolation.prototype.tokens = ['STRING_START', 'STRING_END'];\n\n  function NoNestedStringInterpolation() {\n    this.startedStrings = 0;\n    this.generatedError = false;\n  }\n\n  NoNestedStringInterpolation.prototype.lintToken = function(arg, tokenApi) {\n    var type;\n    type = arg[0];\n    if (type === 'STRING_START') {\n      return this.trackStringStart();\n    } else {\n      return this.trackStringEnd();\n    }\n  };\n\n  NoNestedStringInterpolation.prototype.trackStringStart = function() {\n    this.startedStrings += 1;\n    if (this.startedStrings <= 1 || this.generatedError) {\n      return;\n    }\n    this.generatedError = true;\n    return true;\n  };\n\n  NoNestedStringInterpolation.prototype.trackStringEnd = function() {\n    this.startedStrings -= 1;\n    if (this.startedStrings === 1) {\n      return this.generatedError = false;\n    }\n  };\n\n  return NoNestedStringInterpolation;\n\n})();\n\n\n},{}],31:[function(require,module,exports){\nvar NoPlusPlus;\n\nmodule.exports = NoPlusPlus = (function() {\n  function NoPlusPlus() {}\n\n  NoPlusPlus.prototype.rule = {\n    name: 'no_plusplus',\n    level: 'ignore',\n    message: 'The increment and decrement operators are forbidden',\n    description: 'This rule forbids the increment and decrement arithmetic operators.\\nSome people believe the <tt>++</tt> and <tt>--</tt> to be cryptic\\nand the cause of bugs due to misunderstandings of their precedence\\nrules.\\nThis rule is disabled by default.'\n  };\n\n  NoPlusPlus.prototype.tokens = ['++', '--'];\n\n  NoPlusPlus.prototype.lintToken = function(token, tokenApi) {\n    return {\n      context: \"found '\" + token[0] + \"'\"\n    };\n  };\n\n  return NoPlusPlus;\n\n})();\n\n\n},{}],32:[function(require,module,exports){\nvar NoPrivateFunctionFatArrows,\n  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\nmodule.exports = NoPrivateFunctionFatArrows = (function() {\n  function NoPrivateFunctionFatArrows() {\n    this.isFatArrowCode = bind(this.isFatArrowCode, this);\n    this.isObject = bind(this.isObject, this);\n    this.isValue = bind(this.isValue, this);\n    this.isClass = bind(this.isClass, this);\n    this.isCode = bind(this.isCode, this);\n  }\n\n  NoPrivateFunctionFatArrows.prototype.rule = {\n    name: 'no_private_function_fat_arrows',\n    level: 'warn',\n    message: 'Used the fat arrow for a private function',\n    description: 'Warns when you use the fat arrow for a private function\\ninside a class definition scope. It is not necessary and\\nit does not do anything.'\n  };\n\n  NoPrivateFunctionFatArrows.prototype.lintAST = function(node, astApi) {\n    this.astApi = astApi;\n    this.lintNode(node);\n    return void 0;\n  };\n\n  NoPrivateFunctionFatArrows.prototype.lintNode = function(node, functions) {\n    var error;\n    if (functions == null) {\n      functions = [];\n    }\n    if (this.isFatArrowCode(node) && indexOf.call(functions, node) >= 0) {\n      error = this.astApi.createError({\n        lineNumber: node.locationData.first_line + 1\n      });\n      this.errors.push(error);\n    }\n    return node.eachChild((function(_this) {\n      return function(child) {\n        return _this.lintNode(child, (function() {\n          switch (false) {\n            case !this.isClass(node):\n              return this.functionsOfClass(node);\n            case !this.isCode(node):\n              return [];\n            default:\n              return functions;\n          }\n        }).call(_this));\n      };\n    })(this));\n  };\n\n  NoPrivateFunctionFatArrows.prototype.isCode = function(node) {\n    return this.astApi.getNodeName(node) === 'Code';\n  };\n\n  NoPrivateFunctionFatArrows.prototype.isClass = function(node) {\n    return this.astApi.getNodeName(node) === 'Class';\n  };\n\n  NoPrivateFunctionFatArrows.prototype.isValue = function(node) {\n    return this.astApi.getNodeName(node) === 'Value';\n  };\n\n  NoPrivateFunctionFatArrows.prototype.isObject = function(node) {\n    return this.astApi.getNodeName(node) === 'Obj';\n  };\n\n  NoPrivateFunctionFatArrows.prototype.isFatArrowCode = function(node) {\n    return this.isCode(node) && node.bound;\n  };\n\n  NoPrivateFunctionFatArrows.prototype.functionsOfClass = function(classNode) {\n    var bodyNode, bodyValues;\n    bodyValues = (function() {\n      var i, len, ref, results;\n      ref = classNode.body.expressions;\n      results = [];\n      for (i = 0, len = ref.length; i < len; i++) {\n        bodyNode = ref[i];\n        if (this.isValue(bodyNode) && this.isObject(bodyNode.base)) {\n          continue;\n        }\n        results.push(bodyNode.value);\n      }\n      return results;\n    }).call(this);\n    return bodyValues.filter(this.isCode);\n  };\n\n  return NoPrivateFunctionFatArrows;\n\n})();\n\n\n},{}],33:[function(require,module,exports){\nvar NoStandAloneAt;\n\nmodule.exports = NoStandAloneAt = (function() {\n  function NoStandAloneAt() {}\n\n  NoStandAloneAt.prototype.rule = {\n    name: 'no_stand_alone_at',\n    level: 'ignore',\n    message: '@ must not be used stand alone',\n    description: 'This rule checks that no stand alone @ are in use, they are\\ndiscouraged. Further information in CoffeeScript issue <a\\nhref=\"https://github.com/jashkenas/coffee-script/issues/1601\">\\n#1601</a>'\n  };\n\n  NoStandAloneAt.prototype.tokens = ['@'];\n\n  NoStandAloneAt.prototype.lintToken = function(token, tokenApi) {\n    var isAStart, isDot, isProp, isProtoProp, nextToken, noSpace, ref, ref1;\n    nextToken = tokenApi.peek()[0];\n    noSpace = !token.spaced;\n    isProp = nextToken === 'IDENTIFIER' || nextToken === 'PROPERTY';\n    isAStart = nextToken === 'INDEX_START' || nextToken === 'CALL_START';\n    isDot = nextToken === '.';\n    isProtoProp = nextToken === '::' && ((ref = (ref1 = tokenApi.peek(2)) != null ? ref1[0] : void 0) === 'IDENTIFIER' || ref === 'PROPERTY');\n    if (!(isDot || (noSpace && (isProp || isAStart || isProtoProp)))) {\n      return true;\n    }\n  };\n\n  return NoStandAloneAt;\n\n})();\n\n\n},{}],34:[function(require,module,exports){\nvar NoTabs, indentationRegex,\n  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\nindentationRegex = /\\S/;\n\nmodule.exports = NoTabs = (function() {\n  function NoTabs() {}\n\n  NoTabs.prototype.rule = {\n    name: 'no_tabs',\n    level: 'error',\n    message: 'Line contains tab indentation',\n    description: 'This rule forbids tabs in indentation. Enough said. It is enabled by\\ndefault.'\n  };\n\n  NoTabs.prototype.lintLine = function(line, lineApi) {\n    var indentation;\n    indentation = line.split(indentationRegex)[0];\n    if (lineApi.lineHasToken() && indexOf.call(indentation, '\\t') >= 0) {\n      return true;\n    } else {\n      return null;\n    }\n  };\n\n  return NoTabs;\n\n})();\n\n\n},{}],35:[function(require,module,exports){\nvar NoThis;\n\nmodule.exports = NoThis = (function() {\n  function NoThis() {}\n\n  NoThis.prototype.rule = {\n    name: 'no_this',\n    level: 'ignore',\n    message: \"Don't use 'this', use '@' instead\",\n    description: 'This rule prohibits \\'this\\'.\\nUse \\'@\\' instead.'\n  };\n\n  NoThis.prototype.tokens = ['THIS'];\n\n  NoThis.prototype.lintToken = function(token, tokenApi) {\n    var level, nextToken, ref;\n    level = tokenApi.config.no_stand_alone_at.level;\n    nextToken = (ref = tokenApi.peek(1)) != null ? ref[0] : void 0;\n    if (!(level !== 'ignore' && nextToken !== '.')) {\n      return true;\n    }\n  };\n\n  return NoThis;\n\n})();\n\n\n},{}],36:[function(require,module,exports){\nvar NoThrowingStrings;\n\nmodule.exports = NoThrowingStrings = (function() {\n  function NoThrowingStrings() {}\n\n  NoThrowingStrings.prototype.rule = {\n    name: 'no_throwing_strings',\n    level: 'error',\n    message: 'Throwing strings is forbidden',\n    description: 'This rule forbids throwing string literals or interpolations. While\\nJavaScript (and CoffeeScript by extension) allow any expression to\\nbe thrown, it is best to only throw <a\\nhref=\"https://developer.mozilla.org\\n/en/JavaScript/Reference/Global_Objects/Error\"> Error</a> objects,\\nbecause they contain valuable debugging information like the stack\\ntrace. Because of JavaScript\\'s dynamic nature, CoffeeLint cannot\\nensure you are always throwing instances of <tt>Error</tt>. It will\\nonly catch the simple but real case of throwing literal strings.\\n<pre>\\n<code># CoffeeLint will catch this:\\nthrow \"i made a boo boo\"\\n\\n# ... but not this:\\nthrow getSomeString()\\n</code>\\n</pre>\\nThis rule is enabled by default.'\n  };\n\n  NoThrowingStrings.prototype.tokens = ['THROW'];\n\n  NoThrowingStrings.prototype.lintToken = function(token, tokenApi) {\n    var n1, nextIsString, ref;\n    ref = tokenApi.peek(), n1 = ref[0];\n    nextIsString = n1 === 'STRING' || n1 === 'STRING_START';\n    return nextIsString;\n  };\n\n  return NoThrowingStrings;\n\n})();\n\n\n},{}],37:[function(require,module,exports){\nvar NoTrailingSemicolons, regexes,\n  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },\n  slice = [].slice;\n\nregexes = {\n  trailingSemicolon: /;\\r?$/\n};\n\nmodule.exports = NoTrailingSemicolons = (function() {\n  function NoTrailingSemicolons() {}\n\n  NoTrailingSemicolons.prototype.rule = {\n    name: 'no_trailing_semicolons',\n    level: 'error',\n    message: 'Line contains a trailing semicolon',\n    description: 'This rule prohibits trailing semicolons, since they are needless\\ncruft in CoffeeScript.\\n<pre>\\n<code># This semicolon is meaningful.\\nx = \\'1234\\'; console.log(x)\\n\\n# This semicolon is redundant.\\nalert(\\'end of line\\');\\n</code>\\n</pre>\\nTrailing semicolons are forbidden by default.'\n  };\n\n  NoTrailingSemicolons.prototype.lintLine = function(line, lineApi) {\n    var endPos, first, hasNewLine, hasSemicolon, i, last, lineTokens, newLine, ref, ref1, startCounter, startPos, stopTokens, tokenLen;\n    lineTokens = lineApi.getLineTokens();\n    tokenLen = lineTokens.length;\n    stopTokens = ['TERMINATOR', 'HERECOMMENT'];\n    if (tokenLen === 1 && (ref = lineTokens[0][0], indexOf.call(stopTokens, ref) >= 0)) {\n      return;\n    }\n    newLine = line;\n    if (tokenLen > 1 && lineTokens[tokenLen - 1][0] === 'TERMINATOR') {\n      startPos = lineTokens[tokenLen - 2][2].last_column + 1;\n      endPos = lineTokens[tokenLen - 1][2].first_column;\n      if (startPos !== endPos) {\n        startCounter = startPos;\n        while (line[startCounter] !== '#' && startCounter < line.length) {\n          startCounter++;\n        }\n        newLine = line.substring(0, startCounter).replace(/\\s*$/, '');\n      }\n    }\n    hasSemicolon = regexes.trailingSemicolon.test(newLine);\n    first = 2 <= lineTokens.length ? slice.call(lineTokens, 0, i = lineTokens.length - 1) : (i = 0, []), last = lineTokens[i++];\n    hasNewLine = last && (last.newLine != null);\n    if (hasSemicolon && !hasNewLine && lineApi.lineHasToken() && !((ref1 = last[0]) === 'STRING' || ref1 === 'IDENTIFIER' || ref1 === 'STRING_END')) {\n      return true;\n    }\n  };\n\n  return NoTrailingSemicolons;\n\n})();\n\n\n},{}],38:[function(require,module,exports){\nvar NoTrailingWhitespace, regexes;\n\nregexes = {\n  trailingWhitespace: /[^\\s]+[\\t ]+\\r?$/,\n  onlySpaces: /^[\\t ]+\\r?$/,\n  lineHasComment: /^\\s*[^\\#]*\\#/\n};\n\nmodule.exports = NoTrailingWhitespace = (function() {\n  function NoTrailingWhitespace() {}\n\n  NoTrailingWhitespace.prototype.rule = {\n    name: 'no_trailing_whitespace',\n    level: 'error',\n    message: 'Line ends with trailing whitespace',\n    allowed_in_comments: false,\n    allowed_in_empty_lines: true,\n    description: 'This rule forbids trailing whitespace in your code, since it is\\nneedless cruft. It is enabled by default.'\n  };\n\n  NoTrailingWhitespace.prototype.lintLine = function(line, lineApi) {\n    var i, len, ref, ref1, ref2, str, token, tokens;\n    if (!((ref = lineApi.config['no_trailing_whitespace']) != null ? ref.allowed_in_empty_lines : void 0)) {\n      if (regexes.onlySpaces.test(line)) {\n        return true;\n      }\n    }\n    if (regexes.trailingWhitespace.test(line)) {\n      if (!((ref1 = lineApi.config['no_trailing_whitespace']) != null ? ref1.allowed_in_comments : void 0)) {\n        return true;\n      }\n      line = line;\n      tokens = lineApi.tokensByLine[lineApi.lineNumber];\n      if (!tokens) {\n        return null;\n      }\n      ref2 = (function() {\n        var j, len, results;\n        results = [];\n        for (j = 0, len = tokens.length; j < len; j++) {\n          token = tokens[j];\n          if (token[0] === 'STRING') {\n            results.push(token[1]);\n          }\n        }\n        return results;\n      })();\n      for (i = 0, len = ref2.length; i < len; i++) {\n        str = ref2[i];\n        line = line.replace(str, 'STRING');\n      }\n      if (!regexes.lineHasComment.test(line)) {\n        return true;\n      }\n    }\n  };\n\n  return NoTrailingWhitespace;\n\n})();\n\n\n},{}],39:[function(require,module,exports){\nvar NoUnnecessaryDoubleQuotes;\n\nmodule.exports = NoUnnecessaryDoubleQuotes = (function() {\n  NoUnnecessaryDoubleQuotes.prototype.rule = {\n    name: 'no_unnecessary_double_quotes',\n    level: 'ignore',\n    message: 'Unnecessary double quotes are forbidden',\n    description: 'This rule prohibits double quotes unless string interpolation is\\nused or the string contains single quotes.\\n<pre>\\n<code># Double quotes are discouraged:\\nfoo = \"bar\"\\n\\n# Unless string interpolation is used:\\nfoo = \"#{bar}baz\"\\n\\n# Or they prevent cumbersome escaping:\\nfoo = \"I\\'m just following the \\'rules\\'\"\\n</code>\\n</pre>\\nDouble quotes are permitted by default.'\n  };\n\n  function NoUnnecessaryDoubleQuotes() {\n    this.regexps = [];\n    this.interpolationLevel = 0;\n  }\n\n  NoUnnecessaryDoubleQuotes.prototype.tokens = ['STRING', 'STRING_START', 'STRING_END'];\n\n  NoUnnecessaryDoubleQuotes.prototype.lintToken = function(token, tokenApi) {\n    var hasLegalConstructs, ref, stringValue, tokenValue, type;\n    type = token[0], tokenValue = token[1];\n    if (type === 'STRING_START' || type === 'STRING_END') {\n      return this.trackParens.apply(this, arguments);\n    }\n    stringValue = tokenValue.match(/^\\\"(.*)\\\"$/);\n    if (!stringValue) {\n      return false;\n    }\n    if (((ref = tokenApi.peek(2)) != null ? ref[0] : void 0) === 'REGEX_END') {\n      return false;\n    }\n    hasLegalConstructs = this.isInInterpolation() || this.hasSingleQuote(tokenValue);\n    return !hasLegalConstructs;\n  };\n\n  NoUnnecessaryDoubleQuotes.prototype.isInInterpolation = function() {\n    return this.interpolationLevel > 0;\n  };\n\n  NoUnnecessaryDoubleQuotes.prototype.trackParens = function(token, tokenApi) {\n    if (token[0] === 'STRING_START') {\n      this.interpolationLevel += 1;\n    } else if (token[0] === 'STRING_END') {\n      this.interpolationLevel -= 1;\n    }\n    return null;\n  };\n\n  NoUnnecessaryDoubleQuotes.prototype.hasSingleQuote = function(tokenValue) {\n    return tokenValue.indexOf(\"'\") !== -1;\n  };\n\n  return NoUnnecessaryDoubleQuotes;\n\n})();\n\n\n},{}],40:[function(require,module,exports){\nvar NoUnnecessaryFatArrows, any,\n  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\nany = function(arr, test) {\n  return arr.reduce((function(res, elt) {\n    return res || test(elt);\n  }), false);\n};\n\nmodule.exports = NoUnnecessaryFatArrows = (function() {\n  function NoUnnecessaryFatArrows() {\n    this.needsFatArrow = bind(this.needsFatArrow, this);\n    this.isThis = bind(this.isThis, this);\n  }\n\n  NoUnnecessaryFatArrows.prototype.rule = {\n    name: 'no_unnecessary_fat_arrows',\n    level: 'warn',\n    message: 'Unnecessary fat arrow',\n    description: 'Disallows defining functions with fat arrows when `this`\\nis not used within the function.'\n  };\n\n  NoUnnecessaryFatArrows.prototype.lintAST = function(node, astApi) {\n    this.astApi = astApi;\n    this.lintNode(node);\n    return void 0;\n  };\n\n  NoUnnecessaryFatArrows.prototype.lintNode = function(node) {\n    var error;\n    if ((this.isFatArrowCode(node)) && (!this.needsFatArrow(node))) {\n      error = this.astApi.createError({\n        lineNumber: node.locationData.first_line + 1\n      });\n      this.errors.push(error);\n    }\n    return node.eachChild((function(_this) {\n      return function(child) {\n        return _this.lintNode(child);\n      };\n    })(this));\n  };\n\n  NoUnnecessaryFatArrows.prototype.isCode = function(node) {\n    return this.astApi.getNodeName(node) === 'Code';\n  };\n\n  NoUnnecessaryFatArrows.prototype.isFatArrowCode = function(node) {\n    return this.isCode(node) && node.bound;\n  };\n\n  NoUnnecessaryFatArrows.prototype.isValue = function(node) {\n    return this.astApi.getNodeName(node) === 'Value';\n  };\n\n  NoUnnecessaryFatArrows.prototype.isThis = function(node) {\n    var ref;\n    return ((ref = node.constructor) != null ? ref.name : void 0) === 'ThisLiteral' || this.isValue(node) && node.base.value === 'this';\n  };\n\n  NoUnnecessaryFatArrows.prototype.needsFatArrow = function(node) {\n    return this.isCode(node) && (any(node.params, (function(_this) {\n      return function(param) {\n        return param.contains(_this.isThis) != null;\n      };\n    })(this)) || (node.body.contains(this.isThis) != null) || (node.body.contains((function(_this) {\n      return function(child) {\n        var ref;\n        if (!_this.astApi.getNodeName(child)) {\n          return ((ref = child.constructor) != null ? ref.name : void 0) === 'SuperCall' || ((child.isSuper != null) && child.isSuper);\n        } else {\n          return _this.isFatArrowCode(child) && _this.needsFatArrow(child);\n        }\n      };\n    })(this)) != null));\n  };\n\n  return NoUnnecessaryFatArrows;\n\n})();\n\n\n},{}],41:[function(require,module,exports){\nvar NonEmptyConstructorNeedsParens, ParentClass,\n  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  hasProp = {}.hasOwnProperty;\n\nParentClass = require('./empty_constructor_needs_parens.coffee');\n\nmodule.exports = NonEmptyConstructorNeedsParens = (function(superClass) {\n  extend(NonEmptyConstructorNeedsParens, superClass);\n\n  function NonEmptyConstructorNeedsParens() {\n    return NonEmptyConstructorNeedsParens.__super__.constructor.apply(this, arguments);\n  }\n\n  NonEmptyConstructorNeedsParens.prototype.rule = {\n    name: 'non_empty_constructor_needs_parens',\n    level: 'ignore',\n    message: 'Invoking a constructor without parens and with arguments',\n    description: 'Requires constructors with parameters to include the parens'\n  };\n\n  NonEmptyConstructorNeedsParens.prototype.handleExpectedCallStart = function(isCallStart) {\n    if (isCallStart[0] === 'CALL_START' && isCallStart.generated) {\n      return true;\n    }\n  };\n\n  return NonEmptyConstructorNeedsParens;\n\n})(ParentClass);\n\n\n},{\"./empty_constructor_needs_parens.coffee\":15}],42:[function(require,module,exports){\nvar PreferEnglishOperator;\n\nmodule.exports = PreferEnglishOperator = (function() {\n  function PreferEnglishOperator() {}\n\n  PreferEnglishOperator.prototype.rule = {\n    name: 'prefer_english_operator',\n    level: 'ignore',\n    message: 'Don\\'t use &&, ||, ==, !=, or !',\n    doubleNotLevel: 'ignore',\n    description: 'This rule prohibits &&, ||, ==, != and !.\\nUse and, or, is, isnt, and not instead.\\n!! for converting to a boolean is ignored.'\n  };\n\n  PreferEnglishOperator.prototype.tokens = ['COMPARE', 'UNARY_MATH', 'LOGIC'];\n\n  PreferEnglishOperator.prototype.lintToken = function(token, tokenApi) {\n    var actual_token, config, context, first_column, last_column, level, line, ref;\n    config = tokenApi.config[this.rule.name];\n    level = config.level;\n    ref = token[2], first_column = ref.first_column, last_column = ref.last_column;\n    line = tokenApi.lines[tokenApi.lineNumber];\n    actual_token = line.slice(first_column, +last_column + 1 || 9e9);\n    context = (function() {\n      var ref1, ref2;\n      switch (actual_token) {\n        case '==':\n          return 'Replace \"==\" with \"is\"';\n        case '!=':\n          return 'Replace \"!=\" with \"isnt\"';\n        case '||':\n          return 'Replace \"||\" with \"or\"';\n        case '&&':\n          return 'Replace \"&&\" with \"and\"';\n        case '!':\n          if (((ref1 = tokenApi.peek(1)) != null ? ref1[0] : void 0) === 'UNARY_MATH') {\n            level = config.doubleNotLevel;\n            return '\"?\" is usually better than \"!!\"';\n          } else if (((ref2 = tokenApi.peek(-1)) != null ? ref2[0] : void 0) === 'UNARY_MATH') {\n            return void 0;\n          } else {\n            return 'Replace \"!\" with \"not\"';\n          }\n          break;\n        default:\n          return void 0;\n      }\n    })();\n    if (context != null) {\n      return {\n        level: level,\n        context: context\n      };\n    }\n  };\n\n  return PreferEnglishOperator;\n\n})();\n\n\n},{}],43:[function(require,module,exports){\nvar SpaceOperators,\n  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\nmodule.exports = SpaceOperators = (function() {\n  SpaceOperators.prototype.rule = {\n    name: 'space_operators',\n    level: 'ignore',\n    message: 'Operators must be spaced properly',\n    description: 'This rule enforces that operators have spaces around them.'\n  };\n\n  SpaceOperators.prototype.tokens = ['+', '-', '=', '**', 'MATH', 'COMPARE', 'LOGIC', 'COMPOUND_ASSIGN', 'STRING_START', 'STRING_END', 'CALL_START', 'CALL_END'];\n\n  function SpaceOperators() {\n    this.callTokens = [];\n    this.parenTokens = [];\n    this.interpolationLevel = 0;\n  }\n\n  SpaceOperators.prototype.lintToken = function(arg, tokenApi) {\n    var type;\n    type = arg[0];\n    if (type === 'CALL_START' || type === 'CALL_END') {\n      this.trackCall.apply(this, arguments);\n      return;\n    }\n    if (type === 'STRING_START' || type === 'STRING_END') {\n      return this.trackParens.apply(this, arguments);\n    }\n    if (type === '+' || type === '-') {\n      return this.lintPlus.apply(this, arguments);\n    } else {\n      return this.lintMath.apply(this, arguments);\n    }\n  };\n\n  SpaceOperators.prototype.lintPlus = function(token, tokenApi) {\n    var isUnary, p, ref, unaries;\n    if (this.isInInterpolation() || this.isInExtendedRegex()) {\n      return null;\n    }\n    p = tokenApi.peek(-1);\n    unaries = ['TERMINATOR', '(', '=', '-', '+', ',', 'CALL_START', 'INDEX_START', '..', '...', 'COMPARE', 'IF', 'THROW', 'LOGIC', 'POST_IF', ':', '[', 'INDENT', 'COMPOUND_ASSIGN', 'RETURN', 'MATH', 'BY', 'LEADING_WHEN'];\n    isUnary = !p ? false : (ref = p[0], indexOf.call(unaries, ref) >= 0);\n    if ((isUnary && (token.spaced != null)) || (!isUnary && !token.newLine && (!token.spaced || (p && !p.spaced)))) {\n      return {\n        context: token[1]\n      };\n    } else {\n      return null;\n    }\n  };\n\n  SpaceOperators.prototype.lintMath = function(token, tokenApi) {\n    var p;\n    p = tokenApi.peek(-1);\n    if (!token.newLine && (!token.spaced || (p && !p.spaced))) {\n      return {\n        context: token[1]\n      };\n    } else {\n      return null;\n    }\n  };\n\n  SpaceOperators.prototype.isInExtendedRegex = function() {\n    var i, len, ref, t;\n    ref = this.callTokens;\n    for (i = 0, len = ref.length; i < len; i++) {\n      t = ref[i];\n      if (t.isRegex) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  SpaceOperators.prototype.isInInterpolation = function() {\n    return this.interpolationLevel > 0;\n  };\n\n  SpaceOperators.prototype.trackCall = function(token, tokenApi) {\n    var p;\n    if (token[0] === 'CALL_START') {\n      p = tokenApi.peek(-1);\n      token.isRegex = p && p[0] === 'IDENTIFIER' && p[1] === 'RegExp';\n      this.callTokens.push(token);\n    } else {\n      this.callTokens.pop();\n    }\n    return null;\n  };\n\n  SpaceOperators.prototype.trackParens = function(token, tokenApi) {\n    if (token[0] === 'STRING_START') {\n      this.interpolationLevel += 1;\n    } else if (token[0] === 'STRING_END') {\n      this.interpolationLevel -= 1;\n    }\n    return null;\n  };\n\n  return SpaceOperators;\n\n})();\n\n\n},{}],44:[function(require,module,exports){\nvar SpacingAfterComma;\n\nmodule.exports = SpacingAfterComma = (function() {\n  SpacingAfterComma.prototype.rule = {\n    name: 'spacing_after_comma',\n    level: 'ignore',\n    message: 'a space is required after commas',\n    description: 'This rule checks to make sure you have a space after commas.'\n  };\n\n  SpacingAfterComma.prototype.tokens = [',', 'REGEX_START', 'REGEX_END'];\n\n  function SpacingAfterComma() {\n    this.inRegex = false;\n  }\n\n  SpacingAfterComma.prototype.lintToken = function(token, tokenApi) {\n    var type;\n    type = token[0];\n    if (type === 'REGEX_START') {\n      this.inRegex = true;\n      return;\n    }\n    if (type === 'REGEX_END') {\n      this.inRegex = false;\n      return;\n    }\n    if (!(token.spaced || token.newLine || token.generated || this.isRegexFlag(token, tokenApi))) {\n      return true;\n    }\n  };\n\n  SpacingAfterComma.prototype.isRegexFlag = function(token, tokenApi) {\n    var maybeEnd;\n    if (!this.inRegex) {\n      return false;\n    }\n    maybeEnd = tokenApi.peek(3);\n    return (maybeEnd != null ? maybeEnd[0] : void 0) === 'REGEX_END';\n  };\n\n  return SpacingAfterComma;\n\n})();\n\n\n},{}],45:[function(require,module,exports){\nvar TransformMessesUpLineNumbers;\n\nmodule.exports = TransformMessesUpLineNumbers = (function() {\n  function TransformMessesUpLineNumbers() {}\n\n  TransformMessesUpLineNumbers.prototype.rule = {\n    name: 'transform_messes_up_line_numbers',\n    level: 'warn',\n    message: 'Transforming source messes up line numbers',\n    description: 'This rule detects when changes are made by transform function,\\nand warns that line numbers are probably incorrect.'\n  };\n\n  TransformMessesUpLineNumbers.prototype.tokens = [];\n\n  TransformMessesUpLineNumbers.prototype.lintToken = function(token, tokenApi) {};\n\n  return TransformMessesUpLineNumbers;\n\n})();\n\n\n},{}]},{},[4])(4)\n});","/home/travis/build/npmtest/node-npmtest-coffeelint/node_modules/coffeelint/vowsrunner.js":"#!/usr/bin/env node\nrequire('coffee-script/register')\nrequire('./node_modules/vows/bin/vows')\n\n","/home/travis/build/npmtest/node-npmtest-coffeelint/node_modules/coffeelint/lib/cache.js":"(function() {\n  var Cache, crypto, csVer, fs, ltVer, path;\n\n  fs = require('fs');\n\n  path = require('path');\n\n  crypto = require('crypto');\n\n  ltVer = require('./../package.json').version;\n\n  csVer = ((typeof window !== \"undefined\" && window !== null ? window.CoffeeScript : void 0) || require('coffee-script')).VERSION;\n\n  module.exports = Cache = (function() {\n    function Cache(basepath) {\n      this.basepath = basepath;\n      if (!fs.existsSync(this.basepath)) {\n        fs.mkdirSync(this.basepath, 0x1ed);\n      }\n    }\n\n    Cache.prototype.path = function(source) {\n      return path.join(this.basepath, csVer + \"-\" + ltVer + \"-\" + this.prefix + \"-\" + (this.hash(source)));\n    };\n\n    Cache.prototype.get = function(source) {\n      return JSON.parse(fs.readFileSync(this.path(source), 'utf8'));\n    };\n\n    Cache.prototype.set = function(source, result) {\n      return fs.writeFileSync(this.path(source), JSON.stringify(result));\n    };\n\n    Cache.prototype.has = function(source) {\n      return fs.existsSync(this.path(source));\n    };\n\n    Cache.prototype.hash = function(data) {\n      return crypto.createHash('md5').update('' + data).digest('hex').substring(0, 8);\n    };\n\n    Cache.prototype.setConfig = function(config) {\n      return this.prefix = this.hash(JSON.stringify(config));\n    };\n\n    return Cache;\n\n  })();\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-coffeelint/node_modules/coffeelint/lib/commandline.js":"\n/*\nCoffeeLint\n\nCopyright (c) 2011 Matthew Perpick.\nCoffeeLint is freely distributable under the MIT license.\n */\n\n(function() {\n  var Cache, CoffeeScript, coffeelint, config, configfinder, coreReporters, data, deprecatedReporter, errorReport, findCoffeeScripts, fs, getAllExtention, getFallbackConfig, glob, ignore, jsonIndentation, lintFiles, lintSource, loadConfig, log, logConfig, optimist, options, os, path, paths, read, readConfigFile, ref, reportAndExit, resolve, ruleLoader, scripts, stdin, stripComments, thisdir, userConfig;\n\n  resolve = require('resolve').sync;\n\n  path = require('path');\n\n  fs = require('fs');\n\n  os = require('os');\n\n  glob = require('glob');\n\n  optimist = require('optimist');\n\n  ignore = require('ignore');\n\n  stripComments = require('strip-json-comments');\n\n  thisdir = path.dirname(fs.realpathSync(__filename));\n\n  coffeelint = require(path.join(thisdir, 'coffeelint'));\n\n  configfinder = require(path.join(thisdir, 'configfinder'));\n\n  ruleLoader = require(path.join(thisdir, 'ruleLoader'));\n\n  Cache = require(path.join(thisdir, 'cache'));\n\n  CoffeeScript = require('coffee-script');\n\n  CoffeeScript.register();\n\n  log = function() {\n    return console.log.apply(console, arguments);\n  };\n\n  jsonIndentation = 2;\n\n  logConfig = function(config) {\n    var filter;\n    filter = function(k, v) {\n      if (k !== 'message' && k !== 'description' && k !== 'name') {\n        return v;\n      }\n    };\n    return log(JSON.stringify(config, filter, jsonIndentation));\n  };\n\n  read = function(path) {\n    var realPath;\n    realPath = fs.realpathSync(path);\n    return fs.readFileSync(realPath).toString();\n  };\n\n  getAllExtention = function(extension) {\n    if (extension != null) {\n      extension = ['coffee'].concat(extension != null ? extension.split(',') : void 0);\n      return \"@(\" + (extension.join('|')) + \")\";\n    } else {\n      return 'coffee';\n    }\n  };\n\n  findCoffeeScripts = function(paths, extension) {\n    var allExtention, files, i, len, p;\n    files = [];\n    allExtention = getAllExtention(extension);\n    for (i = 0, len = paths.length; i < len; i++) {\n      p = paths[i];\n      if (fs.statSync(p).isDirectory()) {\n        files = files.concat(glob.sync(p + \"/**/*.\" + allExtention));\n      } else {\n        files.push(p);\n      }\n    }\n    return files.map(function(p) {\n      return path.join(p);\n    });\n  };\n\n  lintFiles = function(files, config) {\n    var errorReport, file, fileConfig, i, len, literate, source;\n    errorReport = new coffeelint.getErrorReport();\n    for (i = 0, len = files.length; i < len; i++) {\n      file = files[i];\n      source = read(file);\n      literate = CoffeeScript.helpers.isLiterate(file);\n      fileConfig = config ? config : getFallbackConfig(file);\n      errorReport.lint(file, source, fileConfig, literate);\n    }\n    return errorReport;\n  };\n\n  lintSource = function(source, config, literate) {\n    var errorReport;\n    if (literate == null) {\n      literate = false;\n    }\n    errorReport = new coffeelint.getErrorReport();\n    config || (config = getFallbackConfig());\n    errorReport.lint('stdin', source, config, literate);\n    return errorReport;\n  };\n\n  readConfigFile = function(path) {\n    var text;\n    text = read(path);\n    try {\n      jsonIndentation = text.split('\\n')[1].match(/^\\s+/)[0].length;\n    } catch (error) {}\n    return JSON.parse(stripComments(text));\n  };\n\n  loadConfig = function(options) {\n    var config;\n    config = null;\n    if (!options.argv.noconfig) {\n      if (options.argv.f) {\n        config = readConfigFile(options.argv.f);\n        if (config.coffeelintConfig) {\n          config = config.coffeelintConfig;\n        }\n      }\n    }\n    return config;\n  };\n\n  getFallbackConfig = function(filename) {\n    if (filename == null) {\n      filename = null;\n    }\n    if (!options.argv.noconfig) {\n      return configfinder.getConfig(filename);\n    }\n  };\n\n  deprecatedReporter = function(errorReport, reporter) {\n    var base;\n    if ((base = errorReport.paths)['coffeelint_fake_file.coffee'] == null) {\n      base['coffeelint_fake_file.coffee'] = [];\n    }\n    errorReport.paths['coffeelint_fake_file.coffee'].push({\n      'level': 'warn',\n      'rule': 'commandline',\n      'message': \"parameter --\" + reporter + \" is deprecated. Use --reporter \" + reporter + \" instead\",\n      'lineNumber': 0\n    });\n    return reporter;\n  };\n\n  coreReporters = {\n    \"default\": require(path.join(thisdir, 'reporters', 'default')),\n    csv: require(path.join(thisdir, 'reporters', 'csv')),\n    jslint: require(path.join(thisdir, 'reporters', 'jslint')),\n    checkstyle: require(path.join(thisdir, 'reporters', 'checkstyle')),\n    raw: require(path.join(thisdir, 'reporters', 'raw'))\n  };\n\n  reportAndExit = function(errorReport, options) {\n    var SelectedReporter, base, colorize, ref, reporter, strReporter;\n    strReporter = options.argv.jslint ? deprecatedReporter(errorReport, 'jslint') : options.argv.csv ? deprecatedReporter(errorReport, 'csv') : options.argv.checkstyle ? deprecatedReporter(errorReport, 'checkstyle') : options.argv.reporter;\n    if (strReporter == null) {\n      strReporter = 'default';\n    }\n    SelectedReporter = (ref = coreReporters[strReporter]) != null ? ref : (function() {\n      var reporterPath;\n      try {\n        reporterPath = resolve(strReporter, {\n          basedir: process.cwd(),\n          extensions: ['.js', '.coffee', '.litcoffee', '.coffee.md']\n        });\n      } catch (error) {\n        reporterPath = strReporter;\n      }\n      return require(reporterPath);\n    })();\n    if ((base = options.argv).color == null) {\n      base.color = options.argv.nocolor ? 'never' : 'auto';\n    }\n    colorize = (function() {\n      switch (options.argv.color) {\n        case 'always':\n          return true;\n        case 'never':\n          return false;\n        default:\n          return process.stdout.isTTY;\n      }\n    })();\n    reporter = new SelectedReporter(errorReport, {\n      colorize: colorize,\n      quiet: options.argv.q\n    });\n    reporter.publish();\n    return process.on('exit', function() {\n      return process.exit(errorReport.getExitCode());\n    });\n  };\n\n  options = optimist.usage('Usage: coffeelint [options] source [...]').alias('f', 'file').alias('h', 'help').alias('v', 'version').alias('s', 'stdin').alias('q', 'quiet').alias('c', 'cache').describe('f', 'Specify a custom configuration file.').describe('rules', 'Specify a custom rule or directory of rules.').describe('makeconfig', 'Prints a default config file').describe('trimconfig', 'Compares your config with the default and prints a minimal configuration').describe('noconfig', 'Ignores any config file.').describe('h', 'Print help information.').describe('v', 'Print current version number.').describe('r', '(not used, but left for backward compatibility)').describe('reporter', 'built in reporter (default, csv, jslint, checkstyle, raw), or module, or path to reporter file.').describe('csv', '[deprecated] use --reporter csv').describe('jslint', '[deprecated] use --reporter jslint').describe('nocolor', '[deprecated] use --color=never').describe('checkstyle', '[deprecated] use --reporter checkstyle').describe('color=<when>', 'When to colorize the output. <when> can be one of always, never , or auto.').describe('s', 'Lint the source from stdin').describe('q', 'Only print errors.').describe('literate', 'Used with --stdin to process as Literate CoffeeScript').describe('c', 'Cache linting results').describe('ext', 'Specify an additional file extension, separated by comma.').boolean('csv').boolean('jslint').boolean('checkstyle').boolean('nocolor').boolean('noconfig').boolean('makeconfig').boolean('trimconfig').boolean('literate').boolean('r').boolean('s').boolean('q', 'Print errors only.').boolean('c');\n\n  if (options.argv.v) {\n    log(coffeelint.VERSION);\n    process.exit(0);\n  } else if (options.argv.h) {\n    options.showHelp();\n    process.exit(0);\n  } else if (options.argv.trimconfig) {\n    userConfig = (ref = loadConfig(options)) != null ? ref : getFallbackConfig();\n    logConfig(coffeelint.trimConfig(userConfig));\n  } else if (options.argv.makeconfig) {\n    logConfig(coffeelint.getRules());\n  } else if (options.argv._.length < 1 && !options.argv.s) {\n    options.showHelp();\n    process.exit(1);\n  } else {\n    if (options.argv.cache) {\n      coffeelint.setCache(new Cache(path.join(os.tmpdir(), 'coffeelint')));\n    }\n    config = loadConfig(options);\n    if (options.argv.rules) {\n      ruleLoader.loadRule(coffeelint, options.argv.rules);\n    }\n    if (options.argv.s) {\n      data = '';\n      stdin = process.openStdin();\n      stdin.on('data', function(buffer) {\n        if (buffer) {\n          return data += buffer.toString();\n        }\n      });\n      stdin.on('end', function() {\n        var errorReport;\n        errorReport = lintSource(data, config, options.argv.literate);\n        return reportAndExit(errorReport, options);\n      });\n    } else {\n      paths = options.argv._;\n      scripts = findCoffeeScripts(paths, options.argv.ext);\n      if (fs.existsSync('.coffeelintignore')) {\n        scripts = ignore().add(fs.readFileSync('.coffeelintignore').toString()).filter(scripts);\n      }\n      errorReport = lintFiles(scripts, config, options.argv.literate);\n      reportAndExit(errorReport, options);\n    }\n  }\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-coffeelint/node_modules/coffeelint/lib/configfinder.js":"\n/*\nHelpers for finding CoffeeLint config in standard locations, similar to how\nJSHint does.\n */\n\n(function() {\n  var expandModuleNames, extendConfig, findFile, findFileResults, fs, getConfig, loadJSON, loadNpmConfig, path, resolve, stripComments;\n\n  fs = require('fs');\n\n  path = require('path');\n\n  stripComments = require('strip-json-comments');\n\n  resolve = require('resolve').sync;\n\n  findFileResults = {};\n\n  findFile = function(name, dir) {\n    var filename, parent;\n    dir = dir || process.cwd();\n    filename = path.normalize(path.join(dir, name));\n    if (findFileResults[filename]) {\n      return findFileResults[filename];\n    }\n    parent = path.resolve(dir, '../');\n    if (fs.existsSync(filename)) {\n      return findFileResults[filename] = filename;\n    } else if (dir === parent) {\n      return findFileResults[filename] = null;\n    } else {\n      return findFile(name, parent);\n    }\n  };\n\n  loadNpmConfig = function(dir) {\n    var fp, ref;\n    fp = findFile('package.json', dir);\n    if (fp) {\n      return (ref = loadJSON(fp)) != null ? ref.coffeelintConfig : void 0;\n    }\n  };\n\n  loadJSON = function(filename) {\n    var e;\n    try {\n      return JSON.parse(stripComments(fs.readFileSync(filename).toString()));\n    } catch (error) {\n      e = error;\n      process.stderr.write(\"Could not load JSON file '\" + filename + \"': \" + e);\n      return null;\n    }\n  };\n\n  getConfig = function(dir) {\n    var envs, home, npmConfig, projConfig;\n    if (process.env.COFFEELINT_CONFIG && fs.existsSync(process.env.COFFEELINT_CONFIG)) {\n      return loadJSON(process.env.COFFEELINT_CONFIG);\n    }\n    npmConfig = loadNpmConfig(dir);\n    if (npmConfig) {\n      return npmConfig;\n    }\n    projConfig = findFile('coffeelint.json', dir);\n    if (projConfig) {\n      return loadJSON(projConfig);\n    }\n    envs = process.env.USERPROFILE || process.env.HOME || process.env.HOMEPATH;\n    home = path.normalize(path.join(envs, 'coffeelint.json'));\n    if (fs.existsSync(home)) {\n      return loadJSON(home);\n    }\n  };\n\n  expandModuleNames = function(dir, config) {\n    var coffeelint, data, ruleName;\n    for (ruleName in config) {\n      data = config[ruleName];\n      if (!((data != null ? data.module : void 0) != null)) {\n        continue;\n      }\n      config[ruleName]._module = config[ruleName].module;\n      config[ruleName].module = resolve(data.module, {\n        basedir: dir,\n        extensions: ['.js', '.coffee', '.litcoffee', '.coffee.md']\n      });\n    }\n    coffeelint = config.coffeelint;\n    if ((coffeelint != null ? coffeelint.transforms : void 0) != null) {\n      coffeelint._transforms = coffeelint.transforms;\n      coffeelint.transforms = coffeelint.transforms.map(function(moduleName) {\n        return resolve(moduleName, {\n          basedir: dir,\n          extensions: ['.js', '.coffee', '.litcoffee', '.coffee.md']\n        });\n      });\n    }\n    if ((coffeelint != null ? coffeelint.coffeescript : void 0) != null) {\n      coffeelint._coffeescript = coffeelint.coffeescript;\n      coffeelint.coffeescript = resolve(coffeelint.coffeescript, {\n        basedir: dir,\n        extensions: ['.js', '.coffee', '.litcoffee', '.coffee.md']\n      });\n    }\n    return config;\n  };\n\n  extendConfig = function(config) {\n    var extendedConfig, parentConfig, rule, ruleName;\n    if (!config[\"extends\"]) {\n      return config;\n    }\n    parentConfig = require(config[\"extends\"]);\n    extendedConfig = {};\n    for (ruleName in config) {\n      rule = config[ruleName];\n      extendedConfig[ruleName] = rule;\n    }\n    for (ruleName in parentConfig) {\n      rule = parentConfig[ruleName];\n      extendedConfig[ruleName] = config[ruleName] || rule;\n    }\n    return extendedConfig;\n  };\n\n  exports.getConfig = function(filename) {\n    var config, dir;\n    if (filename == null) {\n      filename = null;\n    }\n    if (filename) {\n      dir = path.dirname(path.resolve(filename));\n    } else {\n      dir = process.cwd();\n    }\n    config = getConfig(dir);\n    if (config) {\n      config = extendConfig(config);\n      config = expandModuleNames(dir, config);\n    }\n    return config;\n  };\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-coffeelint/node_modules/coffeelint/lib/ruleLoader.js":"(function() {\n  var path, resolve;\n\n  path = require('path');\n\n  resolve = require('resolve').sync;\n\n  module.exports = {\n    require: function(moduleName) {\n      var rulePath;\n      try {\n        rulePath = resolve(moduleName, {\n          basedir: process.cwd(),\n          extensions: ['.js', '.coffee', '.litcoffee', '.coffee.md']\n        });\n        return require(rulePath);\n      } catch (error) {}\n      try {\n        return require(moduleName);\n      } catch (error) {}\n      try {\n        return require(path.resolve(process.cwd(), moduleName));\n      } catch (error) {}\n      return require(moduleName);\n    },\n    loadFromConfig: function(coffeelint, config) {\n      var data, results, ruleName;\n      results = [];\n      for (ruleName in config) {\n        data = config[ruleName];\n        if ((data != null ? data.module : void 0) != null) {\n          results.push(this.loadRule(coffeelint, data.module, ruleName));\n        }\n      }\n      return results;\n    },\n    loadRule: function(coffeelint, moduleName, ruleName) {\n      var e, i, len, results, rule, ruleModule;\n      if (ruleName == null) {\n        ruleName = void 0;\n      }\n      try {\n        ruleModule = this.require(moduleName);\n        if (typeof ruleModule === 'function') {\n          return coffeelint.registerRule(ruleModule, ruleName);\n        } else {\n          results = [];\n          for (i = 0, len = ruleModule.length; i < len; i++) {\n            rule = ruleModule[i];\n            results.push(coffeelint.registerRule(rule));\n          }\n          return results;\n        }\n      } catch (error) {\n        e = error;\n        console.error(\"Error loading \" + moduleName);\n        throw e;\n      }\n    }\n  };\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-coffeelint/node_modules/coffeelint/lib/reporters/default.js":"(function() {\n  var Reporter,\n    slice = [].slice;\n\n  module.exports = Reporter = (function() {\n    function Reporter(errorReport, options) {\n      this.errorReport = errorReport;\n      if (options == null) {\n        options = {};\n      }\n      this.colorize = options.colorize, this.quiet = options.quiet;\n      this.ok = '';\n      this.warn = '';\n      this.err = '';\n    }\n\n    Reporter.prototype.stylize = function() {\n      var map, message, styles;\n      message = arguments[0], styles = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n      if (!this.colorize) {\n        return message;\n      }\n      map = {\n        bold: [1, 22],\n        yellow: [33, 39],\n        green: [32, 39],\n        red: [31, 39]\n      };\n      return styles.reduce(function(m, s) {\n        return '\\u001b[' + map[s][0] + 'm' + m + '\\u001b[' + map[s][1] + 'm';\n      }, message);\n    };\n\n    Reporter.prototype.publish = function() {\n      var errors, path, paths, report;\n      paths = this.errorReport.paths;\n      report = '';\n      for (path in paths) {\n        errors = paths[path];\n        report += this.reportPath(path, errors);\n      }\n      report += this.reportSummary(this.errorReport.getSummary());\n      report += '';\n      if (!this.quiet || this.errorReport.hasError()) {\n        this.print(report);\n      }\n      return this;\n    };\n\n    Reporter.prototype.reportSummary = function(s) {\n      var e, err, file, msg, p, start, w, warn;\n      start = s.errorCount > 0 ? this.err + \" \" + (this.stylize('Lint!', 'red', 'bold')) : s.warningCount > 0 ? this.warn + \" \" + (this.stylize('Warning!', 'yellow', 'bold')) : this.ok + \" \" + (this.stylize('Ok!', 'green', 'bold'));\n      e = s.errorCount;\n      w = s.warningCount;\n      p = s.pathCount;\n      err = this.plural('error', e);\n      warn = this.plural('warning', w);\n      file = this.plural('file', p);\n      msg = start + \"  \" + e + \" \" + err + \" and \" + w + \" \" + warn + \" in \" + p + \" \" + file;\n      return '\\n' + this.stylize(msg) + '\\n';\n    };\n\n    Reporter.prototype.reportPath = function(path, errors) {\n      var color, e, hasError, hasWarning, i, len, lineEnd, o, output, overall, pathReport, ref;\n      ref = (hasError = this.errorReport.pathHasError(path)) ? [this.err, 'red'] : (hasWarning = this.errorReport.pathHasWarning(path)) ? [this.warn, 'yellow'] : [this.ok, 'green'], overall = ref[0], color = ref[1];\n      pathReport = '';\n      if (!this.quiet || hasError) {\n        pathReport += \"  \" + overall + \" \" + (this.stylize(path, color, 'bold')) + \"\\n\";\n      }\n      for (i = 0, len = errors.length; i < len; i++) {\n        e = errors[i];\n        if (!(!this.quiet || e.level === 'error')) {\n          continue;\n        }\n        o = e.level === 'error' ? this.err : this.warn;\n        lineEnd = '';\n        if (e.lineNumberEnd != null) {\n          lineEnd = \"-\" + e.lineNumberEnd;\n        }\n        output = '#' + e.lineNumber + lineEnd;\n        pathReport += '     ' + (o + \" \" + (this.stylize(output, color)) + \": \" + e.message + \".\");\n        if (e.context) {\n          pathReport += \" \" + e.context + \".\";\n        }\n        pathReport += '\\n';\n      }\n      return pathReport;\n    };\n\n    Reporter.prototype.print = function(message) {\n      return console.log(message);\n    };\n\n    Reporter.prototype.plural = function(str, count) {\n      if (count === 1) {\n        return str;\n      } else {\n        return str + \"s\";\n      }\n    };\n\n    return Reporter;\n\n  })();\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-coffeelint/node_modules/coffeelint/lib/reporters/csv.js":"(function() {\n  var CSVReporter;\n\n  module.exports = CSVReporter = (function() {\n    function CSVReporter(errorReport, options) {\n      this.errorReport = errorReport;\n      if (options == null) {\n        options = {};\n      }\n      this.quiet = options.quiet;\n    }\n\n    CSVReporter.prototype.print = function(message) {\n      return console.log(message);\n    };\n\n    CSVReporter.prototype.publish = function() {\n      var e, errors, f, header, path, ref, results;\n      header = ['path', 'lineNumber', 'lineNumberEnd', 'level', 'message'];\n      this.print(header.join(','));\n      ref = this.errorReport.paths;\n      results = [];\n      for (path in ref) {\n        errors = ref[path];\n        results.push((function() {\n          var i, len, ref1, results1;\n          results1 = [];\n          for (i = 0, len = errors.length; i < len; i++) {\n            e = errors[i];\n            if (!(!this.quiet || e.level === 'error')) {\n              continue;\n            }\n            if (e.context) {\n              e.message += \" \" + e.context + \".\";\n            }\n            f = [path, e.lineNumber, (ref1 = e.lineNumberEnd) != null ? ref1 : e.lineNumberEnd, e.level, e.message];\n            results1.push(this.print(f.join(',')));\n          }\n          return results1;\n        }).call(this));\n      }\n      return results;\n    };\n\n    return CSVReporter;\n\n  })();\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-coffeelint/node_modules/coffeelint/lib/reporters/jslint.js":"(function() {\n  var JSLintReporter;\n\n  module.exports = JSLintReporter = (function() {\n    function JSLintReporter(errorReport, options) {\n      this.errorReport = errorReport;\n      if (options == null) {\n        options = {};\n      }\n      this.quiet = options.quiet;\n    }\n\n    JSLintReporter.prototype.print = function(message) {\n      return console.log(message);\n    };\n\n    JSLintReporter.prototype.publish = function() {\n      var e, errors, i, len, path, ref, ref1;\n      this.print('<?xml version=\"1.0\" encoding=\"utf-8\"?><jslint>');\n      ref = this.errorReport.paths;\n      for (path in ref) {\n        errors = ref[path];\n        if (errors.length) {\n          this.print(\"<file name=\\\"\" + path + \"\\\">\");\n          for (i = 0, len = errors.length; i < len; i++) {\n            e = errors[i];\n            if (!this.quiet || e.level === 'error') {\n              this.print(\"<issue line=\\\"\" + e.lineNumber + \"\\\"\\n        lineEnd=\\\"\" + ((ref1 = e.lineNumberEnd) != null ? ref1 : e.lineNumber) + \"\\\"\\n        reason=\\\"[\" + (this.escape(e.level)) + \"] \" + (this.escape(e.message)) + \"\\\"\\n        evidence=\\\"\" + (this.escape(e.context)) + \"\\\"/>\");\n            }\n          }\n          this.print('</file>');\n        }\n      }\n      return this.print('</jslint>');\n    };\n\n    JSLintReporter.prototype.escape = function(msg) {\n      var i, len, r, replacements;\n      msg = '' + msg;\n      if (!msg) {\n        return;\n      }\n      replacements = [[/&/g, '&amp;'], [/\"/g, '&quot;'], [/</g, '&lt;'], [/>/g, '&gt;'], [/'/g, '&apos;']];\n      for (i = 0, len = replacements.length; i < len; i++) {\n        r = replacements[i];\n        msg = msg.replace(r[0], r[1]);\n      }\n      return msg;\n    };\n\n    return JSLintReporter;\n\n  })();\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-coffeelint/node_modules/coffeelint/lib/reporters/checkstyle.js":"(function() {\n  var CheckstyleReporter, JsLintReporter;\n\n  JsLintReporter = require('./jslint');\n\n  module.exports = CheckstyleReporter = (function() {\n    function CheckstyleReporter(errorReport, options) {\n      this.errorReport = errorReport;\n      if (options == null) {\n        options = {};\n      }\n      this.quiet = options.quiet;\n    }\n\n    CheckstyleReporter.prototype.print = function(message) {\n      return console.log(message);\n    };\n\n    CheckstyleReporter.prototype.escape = JsLintReporter.prototype.escape;\n\n    CheckstyleReporter.prototype.publish = function() {\n      var context, e, errors, i, len, level, path, ref, ref1;\n      this.print('<?xml version=\"1.0\" encoding=\"utf-8\"?>');\n      this.print('<checkstyle version=\"4.3\">');\n      ref = this.errorReport.paths;\n      for (path in ref) {\n        errors = ref[path];\n        if (errors.length) {\n          this.print(\"<file name=\\\"\" + path + \"\\\">\");\n          for (i = 0, len = errors.length; i < len; i++) {\n            e = errors[i];\n            if (!(!this.quiet || e.level === 'error')) {\n              continue;\n            }\n            level = e.level;\n            if (level === 'warn') {\n              level = 'warning';\n            }\n            context = (ref1 = e.context) != null ? ref1 : '';\n            this.print(\"<error line=\\\"\" + e.lineNumber + \"\\\"\\n    severity=\\\"\" + (this.escape(level)) + \"\\\"\\n    message=\\\"\" + (this.escape(e.message + '; context: ' + context)) + \"\\\"\\n    source=\\\"coffeelint\\\"/>\");\n          }\n          this.print('</file>');\n        }\n      }\n      return this.print('</checkstyle>');\n    };\n\n    return CheckstyleReporter;\n\n  })();\n\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-coffeelint/node_modules/coffeelint/lib/reporters/raw.js":"(function() {\n  var RawReporter;\n\n  module.exports = RawReporter = (function() {\n    function RawReporter(errorReport, options) {\n      this.errorReport = errorReport;\n      if (options == null) {\n        options = {};\n      }\n      this.quiet = options.quiet;\n    }\n\n    RawReporter.prototype.print = function(message) {\n      return console.log(message);\n    };\n\n    RawReporter.prototype.publish = function() {\n      var e, er, errors, path, ref;\n      er = {};\n      ref = this.errorReport.paths;\n      for (path in ref) {\n        errors = ref[path];\n        er[path] = (function() {\n          var i, len, results;\n          results = [];\n          for (i = 0, len = errors.length; i < len; i++) {\n            e = errors[i];\n            if (!this.quiet || e.level === 'error') {\n              results.push(e);\n            }\n          }\n          return results;\n        }).call(this);\n      }\n      return this.print(JSON.stringify(er, void 0, 2));\n    };\n\n    return RawReporter;\n\n  })();\n\n}).call(this);\n"}